<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vector Map Designer - Infinite Canvas</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            height: 100vh;
            background: #f0f0f0;
            overflow: hidden;
        }

        header {
            background: #2c3e50;
            color: white;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 100;
        }

        h1 {
            font-size: 24px;
            font-weight: 300;
        }

        .container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .sidebar {
            width: 320px;
            background: white;
            padding: 20px;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
            overflow-y: auto;
            z-index: 50;
        }

        .tool-section {
            margin-bottom: 25px;
        }

        .tool-section h3 {
            font-size: 14px;
            color: #7f8c8d;
            text-transform: uppercase;
            margin-bottom: 10px;
            letter-spacing: 1px;
        }

        .tool-btn {
            width: 100%;
            padding: 12px;
            margin-bottom: 8px;
            border: 2px solid #ecf0f1;
            background: white;
            cursor: pointer;
            border-radius: 4px;
            font-size: 14px;
            transition: all 0.3s;
            text-align: left;
        }

        .tool-btn:hover {
            background: #ecf0f1;
            border-color: #3498db;
        }

        .tool-btn.active {
            background: #3498db;
            color: white;
            border-color: #3498db;
        }

        .tool-btn::before {
            content: '';
            display: inline-block;
            width: 20px;
            height: 20px;
            margin-right: 10px;
            vertical-align: middle;
            border-radius: 3px;
        }

        .tool-btn.highway::before { background: #e74c3c; }
        .tool-btn.road::before { background: #95a5a6; }
        .tool-btn.city::before { 
            background: #f39c12;
            border-radius: 50%;
        }
        .tool-btn.water::before { 
            background: linear-gradient(135deg, #3498db 50%, transparent 50%);
            border: 2px solid #3498db;
        }
        .tool-btn.river::before { 
            background: #3498db;
        }
        .tool-btn.border::before { 
            background: white;
            border: 2px dashed #34495e;
        }

        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: #e8e8e8;
        }

        canvas {
            position: absolute;
            cursor: crosshair;
        }

        canvas.panning {
            cursor: grab !important;
        }

        canvas.panning:active {
            cursor: grabbing !important;
        }

        .zoom-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 10;
        }

        .zoom-btn {
            display: block;
            width: 40px;
            height: 40px;
            margin: 5px 0;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 20px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .zoom-btn:hover {
            background: #2980b9;
        }

        .zoom-level {
            text-align: center;
            font-size: 12px;
            color: #7f8c8d;
            margin: 5px 0;
        }

        .info-panel {
            background: #34495e;
            color: white;
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 13px;
            z-index: 100;
        }

        .coords {
            color: #ecf0f1;
        }

        .scale-info {
            color: #3498db;
            font-weight: bold;
        }

        .action-btn {
            padding: 8px 16px;
            margin-bottom: 8px;
            width: 100%;
            background: #27ae60;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.3s;
        }

        .action-btn:hover {
            background: #229954;
        }

        .action-btn.danger {
            background: #e74c3c;
        }

        .action-btn.danger:hover {
            background: #c0392b;
        }

        .action-btn.secondary {
            background: #95a5a6;
        }

        .action-btn.secondary:hover {
            background: #7f8c8d;
        }

        .action-btn.warning {
            background: #f39c12;
        }

        .action-btn.warning:hover {
            background: #e67e22;
        }

        input[type="text"], input[type="number"] {
            width: 100%;
            padding: 8px;
            margin-top: 5px;
            border: 1px solid #bdc3c7;
            border-radius: 4px;
            font-size: 13px;
        }

        label {
            display: block;
            margin-bottom: 10px;
            font-size: 13px;
            color: #34495e;
        }

        .info-box {
            background: #ecf0f1;
            padding: 12px;
            border-radius: 4px;
            margin-bottom: 15px;
            font-size: 12px;
            color: #2c3e50;
            line-height: 1.6;
        }

        .info-box strong {
            color: #e74c3c;
        }

        .selected-info {
            background: #3498db;
            color: white;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 10px;
            font-size: 12px;
        }

        .selected-info .distance {
            font-size: 18px;
            font-weight: bold;
            margin: 5px 0;
        }

        .selected-info .area {
            font-size: 18px;
            font-weight: bold;
            margin: 5px 0;
            color: #f39c12;
        }

        .hover-tooltip {
            position: absolute;
            background: rgba(44, 62, 80, 0.95);
            color: white;
            padding: 10px 15px;
            border-radius: 6px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            display: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .hover-tooltip.show {
            display: block;
        }

        .hover-tooltip .segment-dist {
            color: #f39c12;
            font-weight: bold;
            font-size: 14px;
        }

        .hover-tooltip .total-dist {
            color: #3498db;
            font-weight: bold;
            font-size: 14px;
        }

        .hover-tooltip .area-display {
            color: #2ecc71;
            font-weight: bold;
            font-size: 14px;
        }

        .edit-mode-banner {
            background: #f39c12;
            color: white;
            padding: 10px 20px;
            text-align: center;
            font-weight: bold;
            display: none;
        }

        .edit-mode-banner.active {
            display: block;
        }
    </style>
</head>
<body>
    <header>
        <h1>üó∫Ô∏è Vector Map Designer - Infinite Canvas</h1>
    </header>

    <div class="edit-mode-banner" id="editModeBanner">
        üîß EDIT MODE: Drag vertices to move them. Click vertices to delete. Click segments to delete. Click between to add points.
    </div>

    <div class="container">
        <div class="sidebar">
            
            <div class="info-box">
                <strong>Click</strong> to add points. <strong>Double-click</strong> or <strong>Enter</strong> to finish. <strong>Hover</strong> to see distances/area. <strong>Right-click</strong> a path to select it.
            </div>

            <div class="tool-section">
                <h3>Drawing Tools</h3>
                <button class="tool-btn" onclick="setTool('vertex-select', this)" style="background: #ecf0f1; color: #2c3e50;">‚úã Vertex Select</button>
                <button class="tool-btn" onclick="setTool('add-vertex', this)" style="background: #ecf0f1; color: #2c3e50;">‚ûï Add Vertex</button>
                <button class="tool-btn highway active" onclick="setTool('highway', this)">Highway</button>
                <button class="tool-btn road" onclick="setTool('road', this)">Road</button>
                <button class="tool-btn river" onclick="setTool('river', this)">River</button>
                <button class="tool-btn water" onclick="setTool('water', this)">Water Body (Polygon)</button>
                <button class="tool-btn border" onclick="setTool('border', this)">Border/Boundary</button>
            </div>

            <div class="tool-section">
                <h3>Placement Tools</h3>
                <button class="tool-btn city" onclick="setTool('city', this)">City</button>
                <label>
                    City Name:
                    <input type="text" id="cityName" placeholder="Enter city name">
                </label>
            </div>

            <div class="tool-section" id="selectedPathInfo" style="display: none;">
                <h3>Selected Path</h3>
                <div class="selected-info">
                    <div>Type: <span id="selectedType">-</span></div>
                    <div class="distance"><span id="selectedDistance">0</span> km</div>
                    <div id="areaDisplay" style="display: none;" class="area"><span id="selectedArea">0</span> km¬≤</div>
                    <div>Points: <span id="selectedPoints">0</span></div>
                </div>
                <button class="action-btn warning" onclick="enterEditMode()">‚úèÔ∏è Edit Path</button>
                <button class="action-btn danger" onclick="deleteSelected()">üóëÔ∏è Delete Entire Path</button>
            </div>

            <div class="tool-section" id="editModeControls" style="display: none;">
                <h3>Edit Mode</h3>
                <div class="info-box">
                    <strong>Drag vertex:</strong> Move it.<br>
                    <strong>Click endpoint:</strong> Extend path.<br>
                    <strong>Click middle vertex:</strong> Delete it.<br>
                    <strong>Click segment:</strong> Delete it.<br>
                    <strong>Click between:</strong> Add point.
                </div>
                <button class="action-btn secondary" onclick="exitEditMode()">‚úì Finish Editing</button>
            </div>

            <div class="tool-section">
                <h3>Actions</h3>
                <button class="action-btn secondary" onclick="finishCurrentPath()">‚úì Finish Path (Enter)</button>
                <button class="action-btn" onclick="undo()">‚ü≤ Undo</button>
                <button class="action-btn" onclick="exportSVG()">üìê Export SVG</button>
                <button class="action-btn" onclick="exportJSON()">üìÑ Export JSON</button>
                <button class="action-btn" onclick="exportMap()">üíæ Export PNG</button>
                <button class="action-btn danger" onclick="clearCanvas()">üóëÔ∏è Clear All</button>
            </div>

            <div class="tool-section">
                <h3>View Settings</h3>
                <label>
                    Base Scale (pixels per km):
                    <input type="number" id="baseScale" value="10" min="1" max="100" onchange="updateBaseScale()">
                </label>
            </div>
        </div>

        <div class="canvas-container" id="canvasContainer">
            <canvas id="mapCanvas"></canvas>
            <div class="zoom-controls">
                <button class="zoom-btn" onclick="zoomIn()">+</button>
                <div class="zoom-level"><span id="zoomLevel">100</span>%</div>
                <button class="zoom-btn" onclick="zoomOut()">‚àí</button>
                <button class="zoom-btn" onclick="resetZoom()" style="font-size: 16px; margin-top: 10px;">‚äô</button>
            </div>
        </div>
    </div>

    <div class="info-panel">
        <div class="coords">
            Position: <span id="coords">0.00, 0.00 km</span> | Tool: <span id="currentToolDisplay">Highway</span> | <span id="drawingStatus">Ready</span>
        </div>
        <div class="scale-info">
            Zoom: <span id="zoomDisplay">100%</span> | Effective Scale: <span id="scaleDisplay">10 px/km</span>
        </div>
    </div>

    <div class="hover-tooltip" id="hoverTooltip">
        <div id="segmentInfo" style="display: none;">Segment: <span class="segment-dist" id="segmentDist">0.00 km</span></div>
        <div id="totalInfo" style="display: none;">Total Path: <span class="total-dist" id="totalDist">0.00 km</span></div>
        <div id="areaInfo" style="display: none;">Area: <span class="area-display" id="areaDist">0.00 km¬≤</span></div>
    </div>

    <script>
            const canvas = document.getElementById('mapCanvas');
            const ctx = canvas.getContext('2d');
            const container = document.getElementById('canvasContainer');
            const tooltip = document.getElementById('hoverTooltip');
            
            // Canvas and view state
            let viewOffsetX = 0;
            let viewOffsetY = 0;
            let zoomLevel = 1.0;
            let baseScale = 10;
            let isPanning = false;
            let spacebarDown = false;
            let lastPanX = 0;
            let lastPanY = 0;
            
            // Drawing state
            let currentTool = 'highway';
            let isDrawingPath = false;
            let currentPathPoints = [];
            let selectedPath = null;
            let hoveredPath = null;
            let hoveredSegment = null;
            
            // Edit mode state
            let isEditMode = false;
            let editingPath = null;
            let hoveredVertex = null;
            let hoveredEditSegment = null;
            let extendingFromVertex = null;
            
        // Mouse position tracking for add-vertex preview
            let lastMouseX = 0;
            let lastMouseY = 0;            
            
            
            // Vertex dragging state (for vertex select tool)
            let draggingVertex = null;
            let dragVertexIndex = -1;
            let dragPath = null;



            
            let mapData = {
                highways: [],
                roads: [],
                rivers: [],
                waterBodies: [],
                borders: [],
                cities: []
            };
            let history = [];
            let nextId = 1;
            
            // Initialize canvas
            function resizeCanvas() {
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
                redrawCanvas();
            }
            
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
            saveToHistory();
            
            // Keyboard handlers
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
            
            // Mouse event handlers
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('click', handleClick);
            canvas.addEventListener('dblclick', handleDoubleClick);
            canvas.addEventListener('contextmenu', handleRightClick);
            canvas.addEventListener('wheel', handleWheel, { passive: false });
            
            function handleKeyDown(e) {
                if (e.key === ' ' && !spacebarDown) {
                    e.preventDefault();
                    spacebarDown = true;
                    canvas.classList.add('panning');
                    updateCursor();
                } else if (e.key === 'Enter' && isDrawingPath) {
                    finishCurrentPath();
                } else if (e.key === 'Escape') {
                    if (isEditMode) {
                        exitEditMode();
                    } else if (currentTool === 'vertex-select' && draggingVertex) {
                        // Cancel drag
                        draggingVertex = null;
                        dragVertexIndex = -1;
                        dragPath = null;
                        redrawCanvas();
                    } else {
                        cancelCurrentPath();
                    }
                } else if (e.key === 'Delete' && selectedPath && !isEditMode) {
                    deleteSelected();
                }
            }
            
            function handleKeyUp(e) {
                if (e.key === ' ') {
                    spacebarDown = false;
                    isPanning = false;
                    canvas.classList.remove('panning');
                    updateCursor();
                }
            }
            
            function handleMouseDown(e) {
                if (spacebarDown || e.button === 1) {
                    e.preventDefault();
                    isPanning = true;
                    lastPanX = e.clientX;
                    lastPanY = e.clientY;
                    return;
                }
                
                // Check if using vertex select tool
                if (currentTool === 'vertex-select' && e.button === 0) {
                    const worldPos = screenToWorld(e.clientX, e.clientY);
                    
                    // Find any vertex near the click
                    const allPaths = [
                        ...mapData.highways,
                        ...mapData.roads,
                        ...mapData.rivers,
                        ...mapData.waterBodies,
                        ...mapData.borders
                    ];
                    
                    for (const path of allPaths) {
                        const vertexIndex = findVertexAtPoint(worldPos, path, 0.5);
                        if (vertexIndex !== null) {
                            draggingVertex = true;
                            dragVertexIndex = vertexIndex;
                            dragPath = path;
                            canvas.style.cursor = 'grabbing';
                            e.preventDefault();
                            return;
                        }
                    }
                }
                
                // Check if clicking on a vertex in edit mode
                if (isEditMode && editingPath && e.button === 0) {
                    const worldPos = screenToWorld(e.clientX, e.clientY);
                    const vertexIndex = findVertexAtPoint(worldPos, editingPath, 0.5);
                    if (vertexIndex !== null) {
                        draggingVertex = true;
                        dragVertexIndex = vertexIndex;
                        dragPath = editingPath;
                        canvas.style.cursor = 'grabbing';
                        e.preventDefault();
                    }
                }
            }
            
            function handleMouseUp(e) {
                if (draggingVertex) {
                    draggingVertex = false;
                    dragVertexIndex = -1;
                    dragPath = null;
                    updateCursor();
                    saveToHistory();
                    redrawCanvas();
                    return;
                }
                
                if (isPanning && !spacebarDown) {
                    isPanning = false;
                }
            }
            
        function handleMouseMove(e) {
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            
            // Handle vertex dragging
            if (draggingVertex && dragVertexIndex !== -1 && dragPath) {
                const worldPos = screenToWorld(e.clientX, e.clientY);
                    dragPath.points[dragVertexIndex] = worldPos;
                    redrawCanvas();
                    return;
                }
                
                if (isPanning) {
                    const dx = e.clientX - lastPanX;
                    const dy = e.clientY - lastPanY;
                    viewOffsetX += dx;
                    viewOffsetY += dy;
                    lastPanX = e.clientX;
                    lastPanY = e.clientY;
                    redrawCanvas();
                    return;
                }
            
                const worldPos = screenToWorld(e.clientX, e.clientY);
                updateCoordinates(worldPos);
                

            // Highlight segments when using add-vertex tool
                if (currentTool === 'add-vertex' && !draggingVertex) {
                    let foundSegment = false;
                    const allPaths = [
                        ...mapData.highways,
                        ...mapData.roads,
                        ...mapData.rivers,
                        ...mapData.waterBodies,
                        ...mapData.borders
                    ];
                    
                    for (const path of allPaths) {
                        // Check regular segments
                        for (let i = 1; i < path.points.length; i++) {
                            const dist = distanceToSegment(worldPos, path.points[i-1], path.points[i]);
                            if (dist < 0.5) {
                                hoveredPath = path;
                                hoveredSegment = { start: i - 1, end: i };
                                foundSegment = true;
                                updateCursor();
                                redrawCanvas();
                                break;
                            }
                        }
                        
                        if (foundSegment) break;
                        
                        // For polygons, check closing segment
                        if (path.type === 'water' || path.type === 'border') {
                            const dist = distanceToSegment(worldPos, path.points[path.points.length - 1], path.points[0]);
                            if (dist < 0.5) {
                                hoveredPath = path;
                                hoveredSegment = { start: path.points.length - 1, end: 0 };
                                foundSegment = true;
                                updateCursor();
                                redrawCanvas();
                                break;
                            }
                        }
                    }
                    
                    if (!foundSegment && hoveredSegment !== null) {
                        hoveredSegment = null;
                        hoveredPath = null;
                        updateCursor();
                        redrawCanvas();
                    }
                    
                    tooltip.classList.remove('show');
                    return;
                }

                // Highlight vertices when using vertex select tool
                if (currentTool === 'vertex-select' && !draggingVertex) {
                    let foundVertex = false;
                    const allPaths = [
                        ...mapData.highways,
                        ...mapData.roads,
                        ...mapData.rivers,
                        ...mapData.waterBodies,
                        ...mapData.borders
                    ];
                    
                    for (const path of allPaths) {
                        const vertexIndex = findVertexAtPoint(worldPos, path, 0.5);
                        if (vertexIndex !== null) {
                            hoveredPath = path;
                            hoveredVertex = vertexIndex;
                            foundVertex = true;
                            updateCursor();
                            redrawCanvas();
                            break;
                        }
                    }
                    
                    if (!foundVertex && hoveredVertex !== null) {
                        hoveredVertex = null;
                        hoveredPath = null;
                        updateCursor();
                        redrawCanvas();
                    }
                    
                    tooltip.classList.remove('show');
                    return;
                }
            
                if (isEditMode && editingPath) {
                    const vertex = findVertexAtPoint(worldPos, editingPath);
                    const segment = findEditSegmentAtPoint(worldPos, editingPath);
                    
                    if (vertex !== hoveredVertex || segment !== hoveredEditSegment) {
                        hoveredVertex = vertex;
                        hoveredEditSegment = segment;
                        updateCursor();
                        redrawCanvas();
                    }
                    tooltip.classList.remove('show');
                } else if (extendingFromVertex !== null) {
                    redrawCanvas();
                    drawExtensionPreview(worldPos);
                } else {
                    hoveredVertex = null;
                    hoveredEditSegment = null;
                    
                    const hoverInfo = findPathAndSegmentAtPoint(worldPos);
                    
                    if (hoverInfo) {
                        hoveredPath = hoverInfo.path;
                        hoveredSegment = hoverInfo.segment;
                        
                        const isPolygon = hoverInfo.path.type === 'water' || hoverInfo.path.type === 'border';
                        
                        if (isPolygon && hoverInfo.segment) {
                            const segmentLength = hoverInfo.segmentLength;
                            const totalLength = calculatePathLength([...hoverInfo.path.points, hoverInfo.path.points[0]]);
                            const area = calculatePolygonArea(hoverInfo.path.points);
                            
                            document.getElementById('segmentInfo').style.display = 'block';
                            document.getElementById('totalInfo').style.display = 'block';
                            document.getElementById('areaInfo').style.display = 'block';
                            document.getElementById('segmentDist').textContent = segmentLength.toFixed(2) + ' km';
                            document.getElementById('totalDist').textContent = totalLength.toFixed(2) + ' km';
                            document.getElementById('areaDist').textContent = area.toFixed(2) + ' km¬≤';
                        } else if (!isPolygon) {
                            const segmentLength = hoverInfo.segmentLength;
                            const totalLength = calculatePathLength(hoverInfo.path.points);
                            
                            document.getElementById('segmentInfo').style.display = 'block';
                            document.getElementById('totalInfo').style.display = 'block';
                            document.getElementById('areaInfo').style.display = 'none';
                            document.getElementById('segmentDist').textContent = segmentLength.toFixed(2) + ' km';
                            document.getElementById('totalDist').textContent = totalLength.toFixed(2) + ' km';
                        }
                        
                        tooltip.style.left = (e.clientX + 15) + 'px';
                        tooltip.style.top = (e.clientY + 15) + 'px';
                        tooltip.classList.add('show');
                        
                        redrawCanvas();
                    } else {
                        if (hoveredPath) {
                            hoveredPath = null;
                            hoveredSegment = null;
                            redrawCanvas();
                        }
                        tooltip.classList.remove('show');
                    }
                }
            
                if (isDrawingPath) {
                    redrawCanvas();
                    drawPreviewPoint(worldPos);
                }
            }
            
        function handleClick(e) {
                if (spacebarDown || isPanning || e.button !== 0) return;
                if (draggingVertex) return; // Don't process clicks while dragging
                
                const worldPos = screenToWorld(e.clientX, e.clientY);
                
                // Handle add-vertex tool
                if (currentTool === 'add-vertex') {
                    // Find if we clicked on a segment
                    const allPaths = [
                        ...mapData.highways,
                        ...mapData.roads,
                        ...mapData.rivers,
                        ...mapData.waterBodies,
                        ...mapData.borders
                    ];
                    
                    for (const path of allPaths) {
                        // Check regular segments
                        for (let i = 1; i < path.points.length; i++) {
                            const dist = distanceToSegment(worldPos, path.points[i-1], path.points[i]);
                            if (dist < 0.5) {
                                // Insert vertex at this position
                                path.points.splice(i, 0, worldPos);
                                saveToHistory();
                                redrawCanvas();
                                return;
                            }
                        }
                        
                        // For polygons, also check the closing segment
                        if (path.type === 'water' || path.type === 'border') {
                            const dist = distanceToSegment(worldPos, path.points[path.points.length - 1], path.points[0]);
                            if (dist < 0.5) {
                                // Insert at the end (which closes the polygon)
                                path.points.push(worldPos);
                                saveToHistory();
                                redrawCanvas();
                                return;
                            }
                        }
                    }
                    return;
                }
                
                // Vertex select tool doesn't do anything on click (only drag)
                if (currentTool === 'vertex-select') return;
                
                if (isEditMode && editingPath) {
                    handleEditClick(worldPos);
                } else if (extendingFromVertex !== null) {
                    extendingFromVertex.path.points.push(worldPos);
                    redrawCanvas();
                } else if (currentTool === 'city') {
                    placeCity(worldPos);
                } else {
                    if (!isDrawingPath) {
                        isDrawingPath = true;
                        currentPathPoints = [];
                        selectedPath = null;
                        updateDrawingStatus('Drawing... (double-click or Enter to finish)');
                    }
                    currentPathPoints.push(worldPos);
                    redrawCanvas();
                }
            }
            
            function handleEditClick(worldPos) {
                const vertex = findVertexAtPoint(worldPos, editingPath);
                
                if (vertex !== null) {
                    if (vertex === 0 || vertex === editingPath.points.length - 1) {
                        if (extendingFromVertex !== null) {
                            if (extendingFromVertex.vertexIndex !== vertex) {
                                joinPaths(extendingFromVertex.vertexIndex, vertex);
                            }
                            extendingFromVertex = null;
                        } else {
                            extendingFromVertex = { path: editingPath, vertexIndex: vertex };
                            updateDrawingStatus('Click to add points, click endpoint to join');
                        }
                    } else {
                        deleteVertex(vertex);
                        extendingFromVertex = null;
                    }
                } else {
                    const segment = findEditSegmentAtPoint(worldPos, editingPath);
                    if (segment !== null) {
                        deleteSegment(segment);
                        extendingFromVertex = null;
                    } else {
                        const insertInfo = findInsertionPoint(worldPos, editingPath);
                        if (insertInfo) {
                            insertVertex(insertInfo.index, worldPos);
                        }
                        extendingFromVertex = null;
                    }
                }
                
                redrawCanvas();
            }
            
            function handleDoubleClick(e) {
                e.preventDefault();
                if (spacebarDown || isPanning) return;
                
                if (extendingFromVertex !== null) {
                    extendingFromVertex = null;
                    updateDrawingStatus('Edit mode');
                    redrawCanvas();
                } else if (!isEditMode && currentTool !== 'vertex-select') {
                    finishCurrentPath();
                }
            }
            
            function handleRightClick(e) {
                e.preventDefault();
                if (isPanning || isEditMode) return;
                
                const worldPos = screenToWorld(e.clientX, e.clientY);
                
                const hoverInfo = findPathAndSegmentAtPoint(worldPos);
                if (hoverInfo) {
                    selectedPath = hoverInfo.path;
                    showPathInfo(hoverInfo.path);
                    redrawCanvas();
                }
            }
            
            function handleWheel(e) {
                e.preventDefault();
                
                const zoomChange = e.deltaY < 0 ? 0.01 : -0.01;
                const newZoom = Math.max(0.01, Math.min(50, zoomLevel + zoomChange));
                
                const offsetX = e.clientX - container.getBoundingClientRect().left;
                const offsetY = e.clientY - container.getBoundingClientRect().top;
                
                viewOffsetX = offsetX - (offsetX - viewOffsetX) * (newZoom / zoomLevel);
                viewOffsetY = offsetY - (offsetY - viewOffsetY) * (newZoom / zoomLevel);
                
                zoomLevel = newZoom;
                updateZoomDisplay();
                redrawCanvas();
            }
            
            function screenToWorld(screenX, screenY) {
                const rect = container.getBoundingClientRect();
                const x = (screenX - rect.left - viewOffsetX) / (zoomLevel * baseScale);
                const y = (screenY - rect.top - viewOffsetY) / (zoomLevel * baseScale);
                return { x, y };
            }
            
            function worldToScreen(worldX, worldY) {
                return {
                    x: worldX * baseScale * zoomLevel + viewOffsetX,
                    y: worldY * baseScale * zoomLevel + viewOffsetY
                };
            }
            
            function updateCoordinates(pos) {
                document.getElementById('coords').textContent = `${pos.x.toFixed(2)}, ${pos.y.toFixed(2)} km`;
            }
            
            function updateCursor() {
                if (spacebarDown || isPanning) {
                    return;
                }
                
                if (draggingVertex) {
                    canvas.style.cursor = 'grabbing';
                    return;
                }
                
                if (currentTool === 'vertex-select') {
                    if (hoveredVertex !== null) {
                        canvas.style.cursor = 'grab';
                    } else {
                        canvas.style.cursor = 'default';
                    }
                    return;
                }

            if (currentTool === 'add-vertex') {
                    if (hoveredSegment !== null) {
                        canvas.style.cursor = 'crosshair';
                    } else {
                        canvas.style.cursor = 'default';
                    }
                    return;
                }
                
                if (isEditMode) {
                    if (hoveredVertex !== null) {
                        canvas.style.cursor = 'move';
                    } else {
                        canvas.style.cursor = 'pointer';
                    }
                } else if (currentTool === 'city') {
                    canvas.style.cursor = 'pointer';
                } else {
                    canvas.style.cursor = 'crosshair';
                }
            }
            
            function updateZoomDisplay() {
                const zoomPercent = Math.round(zoomLevel * 100);
                document.getElementById('zoomLevel').textContent = zoomPercent;
                document.getElementById('zoomDisplay').textContent = zoomPercent + '%';
                document.getElementById('scaleDisplay').textContent = (baseScale * zoomLevel).toFixed(2) + ' px/km';
            }
            
            function zoomIn() {
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                
                const newZoom = Math.min(50, zoomLevel + 0.01);
                viewOffsetX = centerX - (centerX - viewOffsetX) * (newZoom / zoomLevel);
                viewOffsetY = centerY - (centerY - viewOffsetY) * (newZoom / zoomLevel);
                
                zoomLevel = newZoom;
                updateZoomDisplay();
                redrawCanvas();
            }
            
            function zoomOut() {
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                
                const newZoom = Math.max(0.01, zoomLevel - 0.01);
                viewOffsetX = centerX - (centerX - viewOffsetX) * (newZoom / zoomLevel);
                viewOffsetY = centerY - (centerY - viewOffsetY) * (newZoom / zoomLevel);
                
                zoomLevel = newZoom;
                updateZoomDisplay();
                redrawCanvas();
            }
            
            function resetZoom() {
                zoomLevel = 1.0;
                viewOffsetX = 0;
                viewOffsetY = 0;
                updateZoomDisplay();
                redrawCanvas();
            }
            
            // Edit mode functions
            function enterEditMode() {
                if (!selectedPath) return;
                
                isEditMode = true;
                editingPath = selectedPath;
                extendingFromVertex = null;
                document.getElementById('editModeBanner').classList.add('active');
                document.getElementById('editModeControls').style.display = 'block';
                document.getElementById('selectedPathInfo').style.display = 'none';
                updateDrawingStatus('Edit mode');
                updateCursor();
                redrawCanvas();
            }
            
            function exitEditMode() {
                isEditMode = false;
                editingPath = null;
                hoveredVertex = null;
                hoveredEditSegment = null;
                extendingFromVertex = null;
                draggingVertex = null;
                dragVertexIndex = -1;
                dragPath = null;
                document.getElementById('editModeBanner').classList.remove('active');
                document.getElementById('editModeControls').style.display = 'none';
                updateDrawingStatus('Ready');
                updateCursor();
                saveToHistory();
                redrawCanvas();
            }
            
            function findVertexAtPoint(pos, path, tolerance = 0.5) {
                for (let i = 0; i < path.points.length; i++) {
                    const dist = calculateSegmentLength(pos, path.points[i]);
                    if (dist < tolerance) {
                        return i;
                    }
                }
                return null;
            }
            
            function findEditSegmentAtPoint(pos, path, tolerance = 0.3) {
                for (let i = 1; i < path.points.length; i++) {
                    const dist = distanceToSegment(pos, path.points[i-1], path.points[i]);
                    if (dist < tolerance) {
                        return { start: i - 1, end: i };
                    }
                }
                return null;
            }
            
            function findInsertionPoint(pos, path, tolerance = 0.5) {
                for (let i = 1; i < path.points.length; i++) {
                    const dist = distanceToSegment(pos, path.points[i-1], path.points[i]);
                    if (dist < tolerance) {
                        return { index: i, segment: { start: i-1, end: i } };
                    }
                }
                return null;
            }
            
            function deleteVertex(vertexIndex) {
                if (!editingPath || editingPath.points.length <= 2) {
                    alert('Cannot delete vertex - path must have at least 2 points');
                    return;
                }
                editingPath.points.splice(vertexIndex, 1);
            }
            
            function deleteSegment(segment) {
                if (!editingPath) return;
                
                const beforePoints = editingPath.points.slice(0, segment.start + 1);
                const afterPoints = editingPath.points.slice(segment.end);
                
                const beforeValid = beforePoints.length >= 2;
                const afterValid = afterPoints.length >= 2;
                
                if (!beforeValid && !afterValid) {
                    const collections = ['highways', 'roads', 'rivers', 'waterBodies', 'borders'];
                    for (const collection of collections) {
                        const index = mapData[collection].findIndex(p => p.id === editingPath.id);
                        if (index !== -1) {
                            mapData[collection].splice(index, 1);
                            exitEditMode();
                            return;
                        }
                    }
                } else if (beforeValid && afterValid) {
                    editingPath.points = beforePoints;
                    
                    const newPath = {
                        id: nextId++,
                        points: afterPoints,
                        type: editingPath.type
                    };
                    
                    const collection = getCollectionForType(editingPath.type);
                    mapData[collection].push(newPath);
                } else if (beforeValid) {
                    editingPath.points = beforePoints;
                } else if (afterValid) {
                    editingPath.points = afterPoints;
                }
                
                redrawCanvas();
            }
    
            function insertVertex(index, pos) {
                if (!editingPath) return;
                editingPath.points.splice(index, 0, pos);
            }
            
            function joinPaths(fromVertex, toVertex) {
                if (!editingPath) return;
                
                if (fromVertex !== 0 && fromVertex !== editingPath.points.length - 1) return;
                if (toVertex !== 0 && toVertex !== editingPath.points.length - 1) return;
                
                if (fromVertex === toVertex) {
                    return;
                }
                
                if (fromVertex === 0) {
                    editingPath.points.reverse();
                }
                
                extendingFromVertex = null;
                updateDrawingStatus('Paths joined');
            }
            
            function getCollectionForType(type) {
                switch(type) {
                    case 'highway': return 'highways';
                    case 'road': return 'roads';
                    case 'river': return 'rivers';
                    case 'water': return 'waterBodies';
                    case 'border': return 'borders';
                    default: return 'highways';
                }
            }
            
            function setTool(tool, buttonElement) {
                if (isEditMode) {
                    exitEditMode();
                }
                
                if (isDrawingPath && tool !== currentTool) {
                    finishCurrentPath();
                }
    
                currentTool = tool;
                
                // Clear any dragging state when switching tools
                draggingVertex = null;
                dragVertexIndex = -1;
                dragPath = null;
                hoveredVertex = null;
                hoveredPath = null;
                
                document.querySelectorAll('.tool-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                buttonElement.classList.add('active');
    
            const toolNames = {
                    'highway': 'Highway',
                    'road': 'Road',
                    'river': 'River',
                    'water': 'Water Body',
                    'border': 'Border',
                    'city': 'City',
                    'vertex-select': 'Vertex Select',
                    'add-vertex': 'Add Vertex'
                };
                
                document.getElementById('currentToolDisplay').textContent = toolNames[tool];
    
                updateCursor();
                updateDrawingStatus('Ready');
                redrawCanvas();
            }
    
            function updateDrawingStatus(status) {
                document.getElementById('drawingStatus').textContent = status;
            }
    
            function finishCurrentPath() {
                if (!isDrawingPath || currentPathPoints.length < 2) {
                    isDrawingPath = false;
                    currentPathPoints = [];
                    updateDrawingStatus('Ready');
                    return;
                }
    
                const pathData = {
                    id: nextId++,
                    points: [...currentPathPoints],
                    type: currentTool
                };
    
                const collection = getCollectionForType(currentTool);
                mapData[collection].push(pathData);
    
                isDrawingPath = false;
                currentPathPoints = [];
                saveToHistory();
                redrawCanvas();
                updateDrawingStatus('Ready');
            }
    
            function cancelCurrentPath() {
                isDrawingPath = false;
                currentPathPoints = [];
                redrawCanvas();
                updateDrawingStatus('Ready');
            }
    
            function placeCity(pos) {
                const cityName = document.getElementById('cityName').value || 'Unnamed City';
                
                mapData.cities.push({
                    id: nextId++,
                    name: cityName,
                    x: pos.x,
                    y: pos.y
                });
    
                saveToHistory();
                redrawCanvas();
            }
    
            function calculatePathLength(points) {
                let totalLength = 0;
                for (let i = 1; i < points.length; i++) {
                    totalLength += calculateSegmentLength(points[i-1], points[i]);
                }
                return totalLength;
            }
    
            function calculateSegmentLength(p1, p2) {
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                return Math.sqrt(dx * dx + dy * dy);
            }
    
            function calculatePolygonArea(points) {
                if (points.length < 3) return 0;
                
                let area = 0;
                for (let i = 0; i < points.length; i++) {
                    const j = (i + 1) % points.length;
                    area += points[i].x * points[j].y;
                    area -= points[j].x * points[i].y;
                }
                return Math.abs(area / 2);
            }
    
            function findPathAndSegmentAtPoint(pos, tolerance = 0.5) {
                const allPaths = [
                    ...mapData.borders.map(p => ({...p, collection: 'borders'})),
                    ...mapData.highways.map(p => ({...p, collection: 'highways'})),
                    ...mapData.roads.map(p => ({...p, collection: 'roads'})),
                    ...mapData.rivers.map(p => ({...p, collection: 'rivers'})),
                    ...mapData.waterBodies.map(p => ({...p, collection: 'waterBodies'}))
                ].reverse();
    
                for (const path of allPaths) {
                    for (let i = 1; i < path.points.length; i++) {
                        const dist = distanceToSegment(pos, path.points[i-1], path.points[i]);
                        if (dist < tolerance) {
                            return {
                                path: path,
                                segment: { start: i - 1, end: i },
                                segmentLength: calculateSegmentLength(path.points[i-1], path.points[i])
                            };
                        }
                    }
                    
                    if (path.type === 'water' || path.type === 'border') {
                        const dist = distanceToSegment(pos, path.points[path.points.length - 1], path.points[0]);
                        if (dist < tolerance) {
                            return {
                                path: path,
                                segment: { start: path.points.length - 1, end: 0 },
                                segmentLength: calculateSegmentLength(path.points[path.points.length - 1], path.points[0])
                            };
                        }
                    }
                }
                return null;
            }
    
            function distanceToSegment(point, segStart, segEnd) {
                const dx = segEnd.x - segStart.x;
                const dy = segEnd.y - segStart.y;
                const lengthSquared = dx * dx + dy * dy;
                
                if (lengthSquared === 0) {
                    return calculateSegmentLength(point, segStart);
                }
                
                const t = Math.max(0, Math.min(1, 
                    ((point.x - segStart.x) * dx + (point.y - segStart.y) * dy) / lengthSquared
                ));
                
                const projX = segStart.x + t * dx;
                const projY = segStart.y + t * dy;
                
                return calculateSegmentLength(point, { x: projX, y: projY });
            }
    
            function showPathInfo(path) {
                const isPolygon = path.type === 'water' || path.type === 'border';
                
                if (isPolygon) {
                    const area = calculatePolygonArea(path.points);
                    const perimeter = calculatePathLength([...path.points, path.points[0]]);
                    document.getElementById('selectedDistance').textContent = perimeter.toFixed(2) + ' (perimeter)';
                    document.getElementById('selectedArea').textContent = area.toFixed(2);
                    document.getElementById('areaDisplay').style.display = 'block';
                } else {
                    const length = calculatePathLength(path.points);
                    document.getElementById('selectedDistance').textContent = length.toFixed(2);
                    document.getElementById('areaDisplay').style.display = 'none';
                }
                
                document.getElementById('selectedType').textContent = path.type.charAt(0).toUpperCase() + path.type.slice(1);
                document.getElementById('selectedPoints').textContent = path.points.length;
                document.getElementById('selectedPathInfo').style.display = 'block';
            }
    
            function deleteSelected() {
                if (!selectedPath) return;
    
                if (!confirm('Delete this entire path?')) return;
    
                const collections = ['highways', 'roads', 'rivers', 'waterBodies', 'borders'];
                for (const collection of collections) {
                    const index = mapData[collection].findIndex(p => p.id === selectedPath.id);
                    if (index !== -1) {
                        mapData[collection].splice(index, 1);
                        break;
                    }
                }
    
                selectedPath = null;
                document.getElementById('selectedPathInfo').style.display = 'none';
                saveToHistory();
                redrawCanvas();
            }
    
            function drawPreviewPoint(pos) {
                if (currentPathPoints.length === 0) return;
    
                const lastPoint = currentPathPoints[currentPathPoints.length - 1];
                const lastScreen = worldToScreen(lastPoint.x, lastPoint.y);
                const posScreen = worldToScreen(pos.x, pos.y);
                
                ctx.save();
                ctx.setLineDash([5, 5]);
                ctx.strokeStyle = '#95a5a6';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(lastScreen.x, lastScreen.y);
                ctx.lineTo(posScreen.x, posScreen.y);
                ctx.stroke();
                ctx.restore();
    
                const dist = calculateSegmentLength(lastPoint, pos);
                const midX = (lastScreen.x + posScreen.x) / 2;
                const midY = (lastScreen.y + posScreen.y) / 2;
    
                ctx.fillStyle = '#2c3e50';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${dist.toFixed(2)} km`, midX, midY - 5);
            }
    
            function drawExtensionPreview(pos) {
                if (!extendingFromVertex) return;
    
                const lastPoint = extendingFromVertex.path.points[extendingFromVertex.vertexIndex];
                const lastScreen = worldToScreen(lastPoint.x, lastPoint.y);
                const posScreen = worldToScreen(pos.x, pos.y);
                
                ctx.save();
                ctx.setLineDash([5, 5]);
                ctx.strokeStyle = '#e74c3c';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(lastScreen.x, lastScreen.y);
                ctx.lineTo(posScreen.x, posScreen.y);
                ctx.stroke();
                ctx.restore();
    
                const dist = calculateSegmentLength(lastPoint, pos);
                const midX = (lastScreen.x + posScreen.x) / 2;
                const midY = (lastScreen.y + posScreen.y) / 2;
    
                ctx.fillStyle = '#e74c3c';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${dist.toFixed(2)} km`, midX, midY - 5);
            }
    
            function clearCanvas() {
                if (confirm('Are you sure you want to clear the entire map?')) {
                    mapData = {
                        highways: [],
                        roads: [],
                        rivers: [],
                        waterBodies: [],
                        borders: [],
                        cities: []
                    };
                    history = [];
                    selectedPath = null;
                    isDrawingPath = false;
                    currentPathPoints = [];
                    isEditMode = false;
                    editingPath = null;
                    extendingFromVertex = null;
                    draggingVertex = null;
                    dragVertexIndex = -1;
                    dragPath = null;
                    document.getElementById('selectedPathInfo').style.display = 'none';
                    document.getElementById('editModeControls').style.display = 'none';
                    document.getElementById('editModeBanner').classList.remove('active');
                    saveToHistory();
                    redrawCanvas();
                }
            }
    
            function saveToHistory() {
                history.push(JSON.parse(JSON.stringify(mapData)));
                if (history.length > 50) {
                    history.shift();
                }
            }
    
            function undo() {
                if (history.length > 1) {
                    history.pop();
                    mapData = JSON.parse(JSON.stringify(history[history.length - 1]));
                    selectedPath = null;
                    isEditMode = false;
                    editingPath = null;
                    extendingFromVertex = null;
                    draggingVertex = null;
                    dragVertexIndex = -1;
                    dragPath = null;
                    document.getElementById('selectedPathInfo').style.display = 'none';
                    document.getElementById('editModeControls').style.display = 'none';
                    document.getElementById('editModeBanner').classList.remove('active');
                    redrawCanvas();
                }
            }
    
            function exportMap() {
                const link = document.createElement('a');
                link.download = 'map-design.png';
                link.href = canvas.toDataURL('image/png');
                link.click();
            }
    
            function exportJSON() {
                const dataStr = JSON.stringify(mapData, null, 2);
                const blob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.download = 'map-data.json';
                link.href = url;
                link.click();
                URL.revokeObjectURL(url);
            }
    
            function redrawCanvas() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#f8f9fa';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
    
                drawGrid();
    
                drawAllPolygons(mapData.waterBodies);
                drawAllPaths(mapData.rivers, 'river');
                drawAllPaths(mapData.roads, 'road');
                drawAllPaths(mapData.highways, 'highway');
                drawAllPolygons(mapData.borders, true);
    
                mapData.cities.forEach(city => drawCity(city));
    
                if (isDrawingPath && currentPathPoints.length > 0) {
                    drawPath(currentPathPoints, currentTool, false, true);
                }
    
                if (selectedPath && !isEditMode) {
                    if (selectedPath.type === 'water' || selectedPath.type === 'border') {
                        drawPolygon(selectedPath.points, true, selectedPath.type === 'border');
                    } else {
                        drawPath(selectedPath.points, selectedPath.type, true, false);
                    }
                }
    
                if (isEditMode && editingPath) {
                    if (editingPath.type === 'water' || editingPath.type === 'border') {
                        drawPolygon(editingPath.points, true, editingPath.type === 'border', true);
                    } else {
                        drawPath(editingPath.points, editingPath.type, true, false, true);
                    }
                }
                
                // Highlight hovered vertex when using vertex select tool
                if (currentTool === 'vertex-select' && hoveredPath && hoveredVertex !== null && !draggingVertex) {
                    const point = hoveredPath.points[hoveredVertex];
                    const screenPoint = worldToScreen(point.x, point.y);
                    
                    ctx.save();
                    ctx.beginPath();
                    ctx.arc(screenPoint.x, screenPoint.y, 12, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(231, 76, 60, 0.5)';
                    ctx.fill();
                    ctx.strokeStyle = '#e74c3c';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    ctx.restore();
                }
                
                // Show insertion preview when using add-vertex tool
                if (currentTool === 'add-vertex' && hoveredPath && hoveredSegment) {
                    const seg = hoveredSegment;
                    const points = hoveredPath.points;
                    
                    if (seg.end === 0) {
                        drawPathSegment(points[seg.start], points[0], hoveredPath.type, true);
                    } else {
                        drawPathSegment(points[seg.start], points[seg.end], hoveredPath.type, true);
                    }
                    
                    // Get mouse position to show where vertex will be inserted
                    const rect = container.getBoundingClientRect();
                    if (lastMouseX !== undefined && lastMouseY !== undefined) {
                        const worldPos = screenToWorld(lastMouseX, lastMouseY);
                        const screenPos = worldToScreen(worldPos.x, worldPos.y);
                        
                        ctx.save();
                        ctx.beginPath();
                        ctx.arc(screenPos.x, screenPos.y, 8, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(46, 204, 113, 0.6)';
                        ctx.fill();
                        ctx.strokeStyle = '#2ecc71';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        ctx.restore();
                    }
                }
    
                if (hoveredPath && hoveredPath !== selectedPath && hoveredSegment && !isEditMode) {
                    const points = hoveredPath.points;
                    const seg = hoveredSegment;
                    if (seg.end === 0) {
                        drawPathSegment(points[seg.start], points[0], hoveredPath.type, true);
                    } else {
                        drawPathSegment(points[seg.start], points[seg.end], hoveredPath.type, true);
                    }
                }
            }
    
            function drawGrid() {
                ctx.save();
                ctx.strokeStyle = '#e0e0e0';
                ctx.lineWidth = 1;
    
                const gridSpacing = 10;
    
                const topLeft = screenToWorld(0, 0);
                const bottomRight = screenToWorld(canvas.width, canvas.height);
    
                const startX = Math.floor(topLeft.x / gridSpacing) * gridSpacing;
                const endX = Math.ceil(bottomRight.x / gridSpacing) * gridSpacing;
                for (let x = startX; x <= endX; x += gridSpacing) {
                    const screenPos = worldToScreen(x, 0);
                    ctx.beginPath();
                    ctx.moveTo(screenPos.x, 0);
                    ctx.lineTo(screenPos.x, canvas.height);
                    ctx.stroke();
                }
    
                const startY = Math.floor(topLeft.y / gridSpacing) * gridSpacing;
                const endY = Math.ceil(bottomRight.y / gridSpacing) * gridSpacing;
                for (let y = startY; y <= endY; y += gridSpacing) {
                    const screenPos = worldToScreen(0, y);
                    ctx.beginPath();
                    ctx.moveTo(0, screenPos.y);
                    ctx.lineTo(canvas.width, screenPos.y);
                    ctx.stroke();
                }
    
                if (zoomLevel > 0.3) {
                    ctx.fillStyle = '#bdc3c7';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'left';
    
                    for (let x = startX; x <= endX; x += gridSpacing) {
                        if (x === 0) continue;
                        const screenPos = worldToScreen(x, Math.max(topLeft.y, 0));
                        ctx.fillText(`${x}km`, screenPos.x + 2, screenPos.y + 12);
                    }
    
                    for (let y = startY; y <= endY; y += gridSpacing) {
                        if (y === 0) continue;
                        const screenPos = worldToScreen(Math.max(topLeft.x, 0), y);
                        ctx.fillText(`${y}km`, screenPos.x + 2, screenPos.y + 12);
                    }
                }
    
                ctx.restore();
            }
    
            function drawAllPaths(paths, type) {
                paths.forEach(path => {
                    drawPath(path.points, type, false, false);
                });
            }
    
            function drawAllPolygons(polygons, isBorder = false) {
                polygons.forEach(polygon => {
                    drawPolygon(polygon.points, false, isBorder);
                });
            }
    
            function drawPolygon(points, isSelected = false, isBorder = false, isEditing = false) {
                if (points.length < 3) return;
    
                ctx.save();
    
                ctx.beginPath();
                const firstPoint = worldToScreen(points[0].x, points[0].y);
                ctx.moveTo(firstPoint.x, firstPoint.y);
                
                for (let i = 1; i < points.length; i++) {
                    const point = worldToScreen(points[i].x, points[i].y);
                    ctx.lineTo(point.x, point.y);
                }
                ctx.closePath();
    
                if (isBorder) {
                    ctx.strokeStyle = '#34495e';
                    ctx.lineWidth = isSelected ? 5 : 3;
                    ctx.setLineDash([10, 5]);
                } else {
                    ctx.fillStyle = 'rgba(52, 152, 219, 0.4)';
                    ctx.fill();
                    ctx.strokeStyle = '#3498db';
                    ctx.lineWidth = isSelected ? 4 : 2;
                }
    
                if (isSelected) {
                    ctx.shadowColor = '#f39c12';
                    ctx.shadowBlur = 10;
                }
                ctx.stroke();
    
                points.forEach((point, index) => {
                    const screenPoint = worldToScreen(point.x, point.y);
                    const isHovered = isEditing && hoveredVertex === index;
                    const isEndpoint = index === 0 || index === points.length - 1;
                    const vertexRadius = isEditing ? 8 : (isSelected ? 5 : 3);
                    
                    ctx.beginPath();
                    ctx.arc(screenPoint.x, screenPoint.y, isHovered ? vertexRadius + 2 : vertexRadius, 0, Math.PI * 2);
                    
                    if (isHovered) {
                        ctx.fillStyle = '#e74c3c';
                    } else if (isEditing && isEndpoint) {
                        ctx.fillStyle = '#2ecc71';
                    } else if (isSelected) {
                        ctx.fillStyle = '#f39c12';
                    } else {
                        ctx.fillStyle = '#2c3e50';
                    }
                    
                    ctx.fill();
                });
    
                if (isEditing && hoveredEditSegment) {
                    const seg = hoveredEditSegment;
                    drawPathSegment(points[seg.start], points[seg.end], isBorder ? 'border' : 'water', true);
                }
    
                ctx.restore();
            }
    
            function drawPath(points, type, isSelected = false, isCurrent = false, isEditing = false) {
                if (points.length < 1) return;
    
                ctx.save();
    
                setDrawStyle(type);
    
                if (isSelected) {
                    ctx.lineWidth += 4;
                    ctx.shadowColor = '#f39c12';
                    ctx.shadowBlur = 10;
                }
    
                if (points.length === 1) {
                    const screenPoint = worldToScreen(points[0].x, points[0].y);
                    ctx.beginPath();
                    ctx.arc(screenPoint.x, screenPoint.y, 3, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    ctx.beginPath();
                    const firstPoint = worldToScreen(points[0].x, points[0].y);
                    ctx.moveTo(firstPoint.x, firstPoint.y);
                    
                    for (let i = 1; i < points.length; i++) {
                        const point = worldToScreen(points[i].x, points[i].y);
                        ctx.lineTo(point.x, point.y);
                    }
                    ctx.stroke();
                }
    
                ctx.globalAlpha = 1;
                
                points.forEach((point, index) => {
                    const screenPoint = worldToScreen(point.x, point.y);
                    const isHovered = isEditing && hoveredVertex === index;
                    const isEndpoint = index === 0 || index === points.length - 1;
                    const isExtending = extendingFromVertex && extendingFromVertex.vertexIndex === index;
                    const vertexRadius = isEditing ? 8 : (isSelected ? 5 : 3);
                    
                    ctx.beginPath();
                    ctx.arc(screenPoint.x, screenPoint.y, isHovered ? vertexRadius + 2 : vertexRadius, 0, Math.PI * 2);
                    
                    if (isExtending) {
                        ctx.fillStyle = '#e74c3c';
                    } else if (isHovered) {
                        ctx.fillStyle = '#e74c3c';
                    } else if (isEditing && isEndpoint) {
                        ctx.fillStyle = '#2ecc71';
                    } else if (isSelected) {
                        ctx.fillStyle = '#f39c12';
                    } else {
                        ctx.fillStyle = '#2c3e50';
                    }
                    
                    ctx.fill();
                });
    
                if (isEditing && hoveredEditSegment) {
                    const seg = hoveredEditSegment;
                    drawPathSegment(points[seg.start], points[seg.end], type, true);
                }
    
                if ((isSelected || isCurrent) && zoomLevel > 0.3) {
                    ctx.font = '11px Arial';
                    ctx.textAlign = 'center';
                    
                    for (let i = 1; i < points.length; i++) {
                        const dist = calculateSegmentLength(points[i-1], points[i]);
                        const midWorld = {
                            x: (points[i-1].x + points[i].x) / 2,
                            y: (points[i-1].y + points[i].y) / 2
                        };
                        const midScreen = worldToScreen(midWorld.x, midWorld.y);
                        
                        ctx.save();
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                        ctx.fillRect(midScreen.x - 25, midScreen.y - 10, 50, 15);
                        ctx.restore();
                        
                        ctx.fillStyle = '#e74c3c';
                        ctx.fillText(`${dist.toFixed(2)} km`, midScreen.x, midScreen.y);
                    }
                }
    
                ctx.restore();
            }
    
            function drawPathSegment(p1, p2, type, isHighlighted = false) {
                ctx.save();
                
                setDrawStyle(type);
                
                if (isHighlighted) {
                    ctx.lineWidth += 3;
                    ctx.shadowColor = '#f39c12';
                    ctx.shadowBlur = 8;
                }
    
                const screen1 = worldToScreen(p1.x, p1.y);
                const screen2 = worldToScreen(p2.x, p2.y);
    
                ctx.beginPath();
                ctx.moveTo(screen1.x, screen1.y);
                ctx.lineTo(screen2.x, screen2.y);
                ctx.stroke();
    
                ctx.restore();
            }
    
            function setDrawStyle(type) {
                ctx.globalAlpha = 1;
                ctx.setLineDash([]);
                
                switch(type) {
                    case 'highway':
                        ctx.strokeStyle = '#e74c3c';
                        ctx.lineWidth = 8;
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';
                        break;
                    case 'road':
                        ctx.strokeStyle = '#95a5a6';
                        ctx.lineWidth = 4;
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';
                        break;
                    case 'river':
                        ctx.strokeStyle = '#3498db';
                        ctx.lineWidth = 6;
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';
                        break;
                    case 'border':
                        ctx.strokeStyle = '#34495e';
                        ctx.lineWidth = 3;
                        ctx.setLineDash([10, 5]);
                        ctx.lineCap = 'butt';
                        ctx.lineJoin = 'miter';
                        break;
                    case 'water':
                        ctx.strokeStyle = '#3498db';
                        ctx.lineWidth = 2;
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';
                        break;
                }
            }
    
            function drawCity(city) {
                const screenPos = worldToScreen(city.x, city.y);
    
                ctx.save();
                ctx.globalAlpha = 1;
                ctx.fillStyle = '#f39c12';
                ctx.beginPath();
                ctx.arc(screenPos.x, screenPos.y, 8, 0, Math.PI * 2);
                ctx.fill();
    
                ctx.strokeStyle = '#e67e22';
                ctx.lineWidth = 2;
                ctx.stroke();
    
                if (zoomLevel > 0.3) {
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(city.name, screenPos.x, screenPos.y - 12);
                }
                ctx.restore();
            }
    
            function exportSVG() {
                const bounds = calculateMapBounds();
                const width = (bounds.maxX - bounds.minX) * baseScale + 100;
                const height = (bounds.maxY - bounds.minY) * baseScale + 100;
                const offsetX = -bounds.minX * baseScale + 50;
                const offsetY = -bounds.minY * baseScale + 50;
    
                let svg = `<?xml version="1.0" encoding="UTF-8"?>
    <svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">
        <desc>Vector map created with Vector Map Designer. Scale: ${baseScale} pixels/km</desc>
        <rect width="100%" height="100%" fill="#f8f9fa"/>
        
    `;
    
                if (mapData.waterBodies.length > 0) {
                    svg += '    <!-- Water Bodies -->\n    <g id="waterBodies">';
                    mapData.waterBodies.forEach((polygon, index) => {
                        const pathD = polygon.points.map((p, i) => 
                            `${i === 0 ? 'M' : 'L'} ${(p.x * baseScale + offsetX).toFixed(2)} ${(p.y * baseScale + offsetY).toFixed(2)}`
                        ).join(' ') + ' Z';
                        const area = calculatePolygonArea(polygon.points);
                        
                        svg += `\n        <path d="${pathD}" fill="rgba(52, 152, 219, 0.4)" stroke="#3498db" stroke-width="2">
                <title>Water Body #${index + 1} - Area: ${area.toFixed(2)} km¬≤</title>
            </path>`;
                    });
                    svg += '\n    </g>\n';
                }
    
                svg += addPathGroup(mapData.rivers, 'rivers', '#3498db', 6, offsetX, offsetY);
                svg += addPathGroup(mapData.roads, 'roads', '#95a5a6', 4, offsetX, offsetY);
                svg += addPathGroup(mapData.highways, 'highways', '#e74c3c', 8, offsetX, offsetY);
                
                if (mapData.borders.length > 0) {
                    svg += '    <!-- Borders -->\n    <g id="borders">';
                    mapData.borders.forEach((polygon, index) => {
                        const pathD = polygon.points.map((p, i) => 
                            `${i === 0 ? 'M' : 'L'} ${(p.x * baseScale + offsetX).toFixed(2)} ${(p.y * baseScale + offsetY).toFixed(2)}`
                        ).join(' ') + ' Z';
                        const area = calculatePolygonArea(polygon.points);
                        
                        svg += `\n        <path d="${pathD}" fill="none" stroke="#34495e" stroke-width="3" stroke-dasharray="10 5">
                <title>Border #${index + 1} - Area: ${area.toFixed(2)} km¬≤</title>
            </path>`;
                    });
                    svg += '\n    </g>\n';
                }
    
                if (mapData.cities.length > 0) {
                    svg += '\n    <!-- Cities -->\n    <g id="cities">';
                    mapData.cities.forEach(city => {
                        svg += `\n        <circle cx="${(city.x * baseScale + offsetX).toFixed(2)}" cy="${(city.y * baseScale + offsetY).toFixed(2)}" r="8" fill="#f39c12" stroke="#e67e22" stroke-width="2">
                <title>${city.name} (${city.x.toFixed(2)}, ${city.y.toFixed(2)} km)</title>
            </circle>
            <text x="${(city.x * baseScale + offsetX).toFixed(2)}" y="${(city.y * baseScale + offsetY - 12).toFixed(2)}" text-anchor="middle" font-family="Arial" font-size="14" font-weight="bold" fill="#2c3e50">${city.name}</text>`;
                    });
                    svg += '\n    </g>';
                }
    
                svg += '\n</svg>';
    
                const blob = new Blob([svg], { type: 'image/svg+xml' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.download = 'map-design.svg';
                link.href = url;
                link.click();
                URL.revokeObjectURL(url);
            }
    
            function addPathGroup(paths, type, color, width, offsetX, offsetY) {
                if (paths.length === 0) return '';
                
                let group = `\n    <!-- ${type} -->\n    <g id="${type}">`;
                paths.forEach((path, index) => {
                    const length = calculatePathLength(path.points);
                    const pathD = path.points.map((p, i) => 
                        `${i === 0 ? 'M' : 'L'} ${(p.x * baseScale + offsetX).toFixed(2)} ${(p.y * baseScale + offsetY).toFixed(2)}`
                    ).join(' ');
                    
                    group += `\n        <path d="${pathD}" stroke="${color}" stroke-width="${width}" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <title>${type} #${index + 1} - ${length.toFixed(2)} km</title>
            </path>`;
                });
                group += '\n    </g>';
                return group;
            }
    
            function calculateMapBounds() {
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    
                [...mapData.highways, ...mapData.roads, ...mapData.rivers, ...mapData.waterBodies, ...mapData.borders].forEach(item => {
                    item.points.forEach(p => {
                        minX = Math.min(minX, p.x);
                        minY = Math.min(minY, p.y);
                        maxX = Math.max(maxX, p.x);
                        maxY = Math.max(maxY, p.y);
                    });
                });
    
                mapData.cities.forEach(city => {
                    minX = Math.min(minX, city.x);
                    minY = Math.min(minY, city.y);
                    maxX = Math.max(maxX, city.x);
                    maxY = Math.max(maxY, city.y);
                });
    
                return minX === Infinity ? { minX: 0, minY: 0, maxX: 100, maxY: 100 } : { minX, minY, maxX, maxY };
            }
    
            function updateBaseScale() {
                const newScale = parseFloat(document.getElementById('baseScale').value);
                if (newScale > 0 && newScale <= 100) {
                    baseScale = newScale;
                    updateZoomDisplay();
                    redrawCanvas();
                } else {
                    alert('Please enter a valid scale between 1 and 100');
                    document.getElementById('baseScale').value = baseScale;
                }
            }
        </script>


        </body>
        </html>