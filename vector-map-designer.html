<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vector Map Designer - Infinite Canvas</title>
    <link rel="stylesheet" href="fontawesome-free-7.1.0-web/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            height: 100vh;
            background: #f0f0f0;
            overflow: hidden;
        }

        header {
            background: #2c3e50;
            color: white;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 100;
        }

        h1 {
            font-size: 24px;
            font-weight: 300;
        }

        .container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .sidebar {
            width: 320px;
            background: white;
            padding: 20px;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
            overflow-y: auto;
            z-index: 50;
        }

        .tool-section {
            margin-bottom: 25px;
        }

        .tool-section h3 {
            font-size: 14px;
            color: #7f8c8d;
            text-transform: uppercase;
            margin-bottom: 10px;
            letter-spacing: 1px;
        }

        .tool-btn {
            width: 100%;
            padding: 12px;
            margin-bottom: 8px;
            border: 2px solid #ecf0f1;
            background: white;
            cursor: pointer;
            border-radius: 4px;
            font-size: 14px;
            transition: all 0.3s;
            text-align: left;
        }

        .tool-btn:hover {
            background: #ecf0f1;
            border-color: #3498db;
        }

        .tool-btn.active {
            background: #3498db;
            color: white;
            border-color: #3498db;
        }

        .tool-btn::before {
            content: '';
            display: inline-block;
            width: 20px;
            height: 20px;
            margin-right: 10px;
            vertical-align: middle;
            border-radius: 3px;
        }

        .tool-btn.highway::before { background: #e74c3c; }
        .tool-btn.road::before { background: #95a5a6; }
        .tool-btn.city::before { 
            background: #f39c12;
            border-radius: 50%;
        }
        .tool-btn.water::before { 
            background: linear-gradient(135deg, #3498db 50%, transparent 50%);
            border: 2px solid #3498db;
        }
        .tool-btn.river::before { 
            background: #3498db;
        }
        .tool-btn.border::before { 
            background: white;
            border: 2px dashed #34495e;
        }

        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: #e8e8e8;
        }

        canvas {
            position: absolute;
            cursor: crosshair;
        }

        canvas.panning {
            cursor: grab !important;
        }

        canvas.panning:active {
            cursor: grabbing !important;
        }

        .zoom-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 10;
        }

        .zoom-btn {
            display: block;
            width: 40px;
            height: 40px;
            margin: 5px 0;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 20px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .zoom-btn:hover {
            background: #2980b9;
        }

        .zoom-level {
            text-align: center;
            font-size: 12px;
            color: #7f8c8d;
            margin: 5px 0;
        }

        .info-panel {
            background: #34495e;
            color: white;
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 13px;
            z-index: 100;
        }

        .coords {
            color: #ecf0f1;
        }

        .scale-info {
            color: #3498db;
            font-weight: bold;
        }

        .action-btn {
            padding: 8px 16px;
            margin-bottom: 8px;
            width: 100%;
            background: #27ae60;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.3s;
        }

        .action-btn:hover {
            background: #229954;
        }

        .action-btn.danger {
            background: #e74c3c;
        }

        .action-btn.danger:hover {
            background: #c0392b;
        }

        .action-btn.secondary {
            background: #95a5a6;
        }

        .action-btn.secondary:hover {
            background: #7f8c8d;
        }

        .action-btn.warning {
            background: #f39c12;
        }

        .action-btn.warning:hover {
            background: #e67e22;
        }

        input[type="text"], input[type="number"] {
            width: 100%;
            padding: 8px;
            margin-top: 5px;
            border: 1px solid #bdc3c7;
            border-radius: 4px;
            font-size: 13px;
        }

        label {
            display: block;
            margin-bottom: 10px;
            font-size: 13px;
            color: #34495e;
        }

        .info-box {
            background: #ecf0f1;
            padding: 12px;
            border-radius: 4px;
            margin-bottom: 15px;
            font-size: 12px;
            color: #2c3e50;
            line-height: 1.6;
        }

        .info-box strong {
            color: #e74c3c;
        }

        .selected-info {
            background: #3498db;
            color: white;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 10px;
            font-size: 12px;
        }

        .selected-info .distance {
            font-size: 18px;
            font-weight: bold;
            margin: 5px 0;
        }

        .selected-info .area {
            font-size: 18px;
            font-weight: bold;
            margin: 5px 0;
            color: #f39c12;
        }

        .hover-tooltip {
            position: absolute;
            background: rgba(44, 62, 80, 0.95);
            color: white;
            padding: 10px 15px;
            border-radius: 6px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            display: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .hover-tooltip.show {
            display: block;
        }

        .hover-tooltip .segment-dist {
            color: #f39c12;
            font-weight: bold;
            font-size: 14px;
        }

        .hover-tooltip .total-dist {
            color: #3498db;
            font-weight: bold;
            font-size: 14px;
        }

        .hover-tooltip .area-display {
            color: #2ecc71;
            font-weight: bold;
            font-size: 14px;
        }

        .edit-mode-banner {
            background: #f39c12;
            color: white;
            padding: 10px 20px;
            text-align: center;
            font-weight: bold;
            display: none;
        }

        .edit-mode-banner.active {
            display: block;
        }
    </style>
</head>
<body>
    <header>
        <h1>üó∫Ô∏è Vector Map Designer - Infinite Canvas</h1>
    </header>

    <div class="edit-mode-banner" id="editModeBanner">
        üîß EDIT MODE: Drag vertices to move them. Click vertices to delete. Click segments to delete. Click between to add points.
    </div>

    <div class="container">
        <div class="sidebar">
            
            <div class="info-box">
                <strong>Click</strong> to add points. <strong>Double-click</strong> or <strong>Enter</strong> to finish. <strong>Hover</strong> to see distances/area. <strong>Right-click</strong> a path to select it.
            </div>

            <div class="tool-section">
                <h3>Drawing Tools</h3>
                <button class="tool-btn" onclick="setTool('vertex-select', this)" style="background: #ecf0f1; color: #2c3e50;">‚úã Vertex Select</button>
                <button class="tool-btn" onclick="setTool('add-vertex', this)" style="background: #ecf0f1; color: #2c3e50;">‚ûï Add Vertex</button>
                <button class="tool-btn highway active" onclick="setTool('highway', this)">Highway</button>
                <button class="tool-btn road" onclick="setTool('road', this)">Road</button>
                <button class="tool-btn river" onclick="setTool('river', this)">River</button>
                <button class="tool-btn water" onclick="setTool('water', this)">Water Body (Polygon)</button>
                <button class="tool-btn border" onclick="setTool('border', this)">Border/Boundary</button>
                <div id="customPathToolsContainer"></div>
            </div>

            <div class="tool-section">
                <h3>Custom Path Tools</h3>
                <button class="action-btn secondary" onclick="openAddCustomPathToolDialog()">‚ûï Add Custom Path Tool</button>
                
                <div id="addCustomPathToolDialog" style="display: none; margin-top: 15px; padding: 15px; border: 2px solid #3498db; border-radius: 4px; background: #ecf0f1;">
                    <h4 style="margin-bottom: 10px; font-size: 13px;">New Custom Path Tool</h4>
                    <label>
                        Tool Name:
                        <input type="text" id="customPathToolName" placeholder="e.g. Trail, Pipeline, Ferry">
                    </label>
                    <label>
                        Path Thickness (px):
                        <input type="number" id="customPathThickness" placeholder="e.g. 4" min="1" max="20" value="4">
                    </label>
                    <label>
                        Path Color:
                        <input type="color" id="customPathColor" value="#8e44ad">
                    </label>
                    <label>
                        Path Style:
                        <select id="customPathStyle">
                            <option value="solid">Solid</option>
                            <option value="dashed">Dashed</option>
                            <option value="dotted">Dotted</option>
                        </select>
                    </label>
                    <div style="margin-top: 10px;">
                        <button class="action-btn secondary" onclick="addCustomPathTool()">‚úì Add Tool</button>
                        <button class="action-btn" onclick="closeAddCustomPathToolDialog()">Cancel</button>
                    </div>
                </div>
            </div>

            <div class="tool-section">
                <h3>Placement Tools</h3>
                <button class="tool-btn city" onclick="setTool('city', this)">City</button>
                <label>
                    City Name:
                    <input type="text" id="cityName" placeholder="Enter city name">
                </label>
                
                <button class="tool-btn" onclick="setTool('custom-point', this)" style="background: #ecf0f1; color: #2c3e50;">üìç Custom Point</button>

                <label>
                    Font Awesome Icon:
                    <input type="text" id="customIcon" placeholder="e.g. tree, hospital, star, mountain, landmark">
                </label>
                <label>
                    Point Label (optional):
                    <input type="text" id="customLabel" placeholder="Enter label">
                </label>
            </div>

            <div class="tool-section" id="selectedPathInfo" style="display: none;">
                <h3>Selected Path</h3>
                <div class="selected-info">
                    <div>Type: <span id="selectedType">-</span></div>
                    <div class="distance"><span id="selectedDistance">0</span> km</div>
                    <div id="areaDisplay" style="display: none;" class="area"><span id="selectedArea">0</span> km¬≤</div>
                    <div>Points: <span id="selectedPoints">0</span></div>
                </div>
                <button class="action-btn warning" onclick="enterEditMode()">‚úèÔ∏è Edit Path</button>
                <button class="action-btn danger" onclick="deleteSelected()">üóëÔ∏è Delete Entire Path</button>

                <button class="tool-btn" onclick="setTool('custom-point', this)" style="background: #ecf0f1; color: #2c3e50;">üìç Custom Point</button>
                <label>
                    Font Awesome Icon:
                    <input type="text" id="customIcon" placeholder="e.g. tree, hospital, star, mountain, landmark">
                </label>
                <label>
                    Point Label (optional):
                    <input type="text" id="customLabel" placeholder="Enter label">
                </label>
                <label>
                    Link URL (optional):
                    <input type="text" id="customURL" placeholder="https://example.com">
                </label>

            </div>

            <div class="tool-section" id="editModeControls" style="display: none;">
                <h3>Edit Mode</h3>
                <div class="info-box">
                    <strong>Drag vertex:</strong> Move it.<br>
                    <strong>Click endpoint:</strong> Extend path.<br>
                    <strong>Click middle vertex:</strong> Delete it.<br>
                    <strong>Click segment:</strong> Delete it.<br>
                    <strong>Click between:</strong> Add point.
                </div>
                <button class="action-btn secondary" onclick="exitEditMode()">‚úì Finish Editing</button>
            </div>

            <div class="tool-section">
                <h3>Actions</h3>
                <button class="action-btn secondary" onclick="finishCurrentPath()">‚úì Finish Path (Enter)</button>
                <button class="action-btn" onclick="undo()">‚ü≤ Undo</button>
                <button class="action-btn" onclick="exportSVG()">üìê Export SVG</button>
                <button class="action-btn" onclick="exportJSON()">üìÑ Export JSON</button>
                <button class="action-btn" onclick="importJSON()">üì• Import JSON</button>
                <button class="action-btn" onclick="exportMap()">üíæ Export PNG</button>
                <button class="action-btn danger" onclick="clearCanvas()">üóëÔ∏è Clear All</button>
            </div>

            <div class="tool-section">
                <h3>View Settings</h3>
                <label>
                    Base Scale (pixels per km):
                    <input type="number" id="baseScale" value="10" min="1" max="100" onchange="updateBaseScale()">
                </label>
                <label>
                    Font Awesome SVG Path:
                    <input type="text" id="svgPath" value="fontawesome-free-7.1.0-web/svgs/regular/" onchange="updateSVGPath()">
                </label>
            </div>

        </div>

        <div class="canvas-container" id="canvasContainer">
            <canvas id="mapCanvas"></canvas>
            <div class="zoom-controls">
                <button class="zoom-btn" onclick="zoomIn()">+</button>
                <div class="zoom-level"><span id="zoomLevel">100</span>%</div>
                <button class="zoom-btn" onclick="zoomOut()">‚àí</button>
                <button class="zoom-btn" onclick="resetZoom()" style="font-size: 16px; margin-top: 10px;">‚äô</button>
            </div>
        </div>
    </div>

    <div class="info-panel">
        <div class="coords">
            Position: <span id="coords">0.00, 0.00 km</span> | Tool: <span id="currentToolDisplay">Highway</span> | <span id="drawingStatus">Ready</span>
        </div>
        <div class="scale-info">
            Zoom: <span id="zoomDisplay">100%</span> | Effective Scale: <span id="scaleDisplay">10 px/km</span>
        </div>
    </div>

    <div class="hover-tooltip" id="hoverTooltip">
        <div id="segmentInfo" style="display: none;">Segment: <span class="segment-dist" id="segmentDist">0.00 km</span></div>
        <div id="totalInfo" style="display: none;">Total Path: <span class="total-dist" id="totalDist">0.00 km</span></div>
        <div id="areaInfo" style="display: none;">Area: <span class="area-display" id="areaDist">0.00 km¬≤</span></div>
    </div>

    <script>
            const canvas = document.getElementById('mapCanvas');
            const ctx = canvas.getContext('2d');
            const container = document.getElementById('canvasContainer');
            const tooltip = document.getElementById('hoverTooltip');
            
            //  STATE VARIABLES
            
            // Canvas and view state
            let viewOffsetX = 0;
            let viewOffsetY = 0;
            let zoomLevel = 1.0;
            let baseScale = 10;
            let isPanning = false;
            let spacebarDown = false;
            let lastPanX = 0;
            let lastPanY = 0;
            
            // Drawing state
            let currentTool = 'highway';
            let isDrawingPath = false;
            let currentPathPoints = [];
            let selectedPath = null;
            let hoveredPath = null;
            let hoveredSegment = null;
            
            // Edit mode state
            let isEditMode = false;
            let editingPath = null;
            let hoveredVertex = null;
            let hoveredEditSegment = null;
            let extendingFromVertex = null;

        // SVG icon cache
            let svgIconCache = {};
            let svgBasePath = 'fontawesome-free-7.1.0-web/svgs/regular/';


        // Custom point editing
            let editingPoint = null;
            let shiftKeyDown = false;
            let draggingPoint = null;
            
        // Mouse position tracking for add-vertex preview
            let lastMouseX = 0;
            let lastMouseY = 0;            
            
            
            // Vertex dragging state (for vertex select tool)
            let draggingVertex = null;
            let dragVertexIndex = -1;
            let dragPath = null;



            
            let mapData = {
                highways: [],
                roads: [],
                rivers: [],
                waterBodies: [],
                borders: [],
                cities: [],
                customPoints: [],
                customPaths: []
            };
            
            // Custom path tool definitions
            let customPathTools = [];
            let history = [];
            let nextId = 1;
            
            // Initialize canvas
            function resizeCanvas() {
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
                redrawCanvas();
            }
            
        window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
            saveToHistory();
            
            // Preload common Font Awesome icons
            preloadCommonIcons();
                        
            // Keyboard handlers
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
            
            // Mouse event handlers
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('click', handleClick);
            canvas.addEventListener('dblclick', handleDoubleClick);
            canvas.addEventListener('contextmenu', handleRightClick);
            canvas.addEventListener('wheel', handleWheel, { passive: false });
            
        function handleKeyDown(e) {
                if (e.key === 'Shift' && !shiftKeyDown) {
                    shiftKeyDown = true;
                    updateCursor();
                } else if (e.key === ' ' && !spacebarDown) {
                    e.preventDefault();
                    spacebarDown = true;
                    canvas.classList.add('panning');
                    updateCursor();
                } else if (e.key === 'Enter' && isDrawingPath) {
                    finishCurrentPath();
                } else if (e.key === 'Escape') {
                    if (isEditMode) {
                        exitEditMode();
                    } else if (currentTool === 'vertex-select' && draggingVertex) {
                        // Cancel drag
                        draggingVertex = null;
                        dragVertexIndex = -1;
                        dragPath = null;
                        redrawCanvas();
                    } else {
                        cancelCurrentPath();
                    }
                } else if (e.key === 'Delete' && selectedPath && !isEditMode) {
                    deleteSelected();
                }
            }
            
        function handleKeyUp(e) {
                if (e.key === 'Shift') {
                    shiftKeyDown = false;
                    draggingPoint = null;
                    updateCursor();
                } else if (e.key === ' ') {
                    spacebarDown = false;
                    isPanning = false;
                    canvas.classList.remove('panning');
                    updateCursor();
                }
            } 

        function handleMouseDown(e) {
                if (spacebarDown || e.button === 1) {
                    e.preventDefault();
                    isPanning = true;
                    lastPanX = e.clientX;
                    lastPanY = e.clientY;
                    return;
                }
                
                const worldPos = screenToWorld(e.clientX, e.clientY);
                
                // Check if shift-clicking a custom point to drag it
                if (shiftKeyDown && e.button === 0) {
                    const point = findCustomPointAtPosition(worldPos);
                    if (point) {
                        draggingPoint = point;
                        canvas.style.cursor = 'grabbing';
                        e.preventDefault();
                        return;
                    }
                }
                
                // Check if using vertex select tool
                if (currentTool === 'vertex-select' && e.button === 0) {
                    const allPaths = [
                        ...mapData.highways,
                        ...mapData.roads,
                        ...mapData.rivers,
                        ...mapData.waterBodies,
                        ...mapData.borders,
                        ...(mapData.customPaths || [])
                    ];
                    
                    for (const path of allPaths) {
                        const vertexIndex = findVertexAtPoint(worldPos, path, 0.5);
                        if (vertexIndex !== null) {
                            draggingVertex = true;
                            dragVertexIndex = vertexIndex;
                            dragPath = path;
                            canvas.style.cursor = 'grabbing';
                            e.preventDefault();
                            return;
                        }
                    }
                }
                
                // Check if clicking on a vertex in edit mode
                if (isEditMode && editingPath && e.button === 0) {
                    const vertexIndex = findVertexAtPoint(worldPos, editingPath, 0.5);
                    if (vertexIndex !== null) {
                        draggingVertex = true;
                        dragVertexIndex = vertexIndex;
                        dragPath = editingPath;
                        canvas.style.cursor = 'grabbing';
                        e.preventDefault();
                    }
                }
            }            


        function handleMouseUp(e) {
                if (draggingPoint) {
                    draggingPoint = null;
                    updateCursor();
                    saveToHistory();
                    redrawCanvas();
                    return;
                }
                
                if (draggingVertex) {
                    draggingVertex = false;
                    dragVertexIndex = -1;
                    dragPath = null;
                    updateCursor();
                    saveToHistory();
                    redrawCanvas();
                    return;
                }
                
                if (isPanning && !spacebarDown) {
                    isPanning = false;
                }
            }
            
                        
        function handleMouseMove(e) {
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;


// Handle custom point dragging
            if (draggingPoint) {
                const worldPos = screenToWorld(e.clientX, e.clientY);
                draggingPoint.x = worldPos.x;
                draggingPoint.y = worldPos.y;
                redrawCanvas();
                return;
            }
            
            // Handle vertex dragging
            if (draggingVertex && dragVertexIndex !== -1 && dragPath) {
                const worldPos = screenToWorld(e.clientX, e.clientY);
                    dragPath.points[dragVertexIndex] = worldPos;
                    redrawCanvas();
                    return;
                }
                
                if (isPanning) {
                    const dx = e.clientX - lastPanX;
                    const dy = e.clientY - lastPanY;
                    viewOffsetX += dx;
                    viewOffsetY += dy;
                    lastPanX = e.clientX;
                    lastPanY = e.clientY;
                    redrawCanvas();
                    return;
                }
            
                const worldPos = screenToWorld(e.clientX, e.clientY);
                updateCoordinates(worldPos);
                

            // Highlight segments when using add-vertex tool
                if (currentTool === 'add-vertex' && !draggingVertex) {
                    let foundSegment = false;
                    const allPaths = [
                        ...mapData.highways,
                        ...mapData.roads,
                        ...mapData.rivers,
                        ...mapData.waterBodies,
                        ...mapData.borders,
                        ...(mapData.customPaths || [])
                    ];
                    
                    for (const path of allPaths) {
                        // Check regular segments
                        for (let i = 1; i < path.points.length; i++) {
                            const dist = distanceToSegment(worldPos, path.points[i-1], path.points[i]);
                            if (dist < 0.5) {
                                hoveredPath = path;
                                hoveredSegment = { start: i - 1, end: i };
                                foundSegment = true;
                                updateCursor();
                                redrawCanvas();
                                break;
                            }
                        }
                        
                        if (foundSegment) break;
                        
                        // For polygons, check closing segment
                        if (path.type === 'water' || path.type === 'border') {
                            const dist = distanceToSegment(worldPos, path.points[path.points.length - 1], path.points[0]);
                            if (dist < 0.5) {
                                hoveredPath = path;
                                hoveredSegment = { start: path.points.length - 1, end: 0 };
                                foundSegment = true;
                                updateCursor();
                                redrawCanvas();
                                break;
                            }
                        }
                    }
                    
                    if (!foundSegment && hoveredSegment !== null) {
                        hoveredSegment = null;
                        hoveredPath = null;
                        updateCursor();
                        redrawCanvas();
                    }
                    
                    tooltip.classList.remove('show');
                    return;
                }

            // Highlight custom points when shift is held
                if (shiftKeyDown && !draggingPoint) {
                    const worldPos = screenToWorld(e.clientX, e.clientY);
                    const point = findCustomPointAtPosition(worldPos);
                    
                    if (point) {
                        canvas.style.cursor = 'grab';
                        // Could add highlighting here if desired
                    } else {
                        updateCursor();
                    }
                    return;
                }


                // Highlight vertices when using vertex select tool
                if (currentTool === 'vertex-select' && !draggingVertex) {
                    let foundVertex = false;
                    const allPaths = [
                        ...mapData.highways,
                        ...mapData.roads,
                        ...mapData.rivers,
                        ...mapData.waterBodies,
                        ...mapData.borders,
                        ...(mapData.customPaths || [])
                    ];
                    
                    for (const path of allPaths) {
                        const vertexIndex = findVertexAtPoint(worldPos, path, 0.5);
                        if (vertexIndex !== null) {
                            hoveredPath = path;
                            hoveredVertex = vertexIndex;
                            foundVertex = true;
                            updateCursor();
                            redrawCanvas();
                            break;
                        }
                    }
                    
                    if (!foundVertex && hoveredVertex !== null) {
                        hoveredVertex = null;
                        hoveredPath = null;
                        updateCursor();
                        redrawCanvas();
                    }
                    
                    tooltip.classList.remove('show');
                    return;
                }
            
                if (isEditMode && editingPath) {
                    const vertex = findVertexAtPoint(worldPos, editingPath);
                    const segment = findEditSegmentAtPoint(worldPos, editingPath);
                    
                    if (vertex !== hoveredVertex || segment !== hoveredEditSegment) {
                        hoveredVertex = vertex;
                        hoveredEditSegment = segment;
                        updateCursor();
                        redrawCanvas();
                    }
                    tooltip.classList.remove('show');
                } else if (extendingFromVertex !== null) {
                    redrawCanvas();
                    drawExtensionPreview(worldPos);
                } else {
                    hoveredVertex = null;
                    hoveredEditSegment = null;
                    
                    const hoverInfo = findPathAndSegmentAtPoint(worldPos);
                    
                    if (hoverInfo) {
                        hoveredPath = hoverInfo.path;
                        hoveredSegment = hoverInfo.segment;
                        
                        const isPolygon = hoverInfo.path.type === 'water' || hoverInfo.path.type === 'border';
                        
                        if (isPolygon && hoverInfo.segment) {
                            const segmentLength = hoverInfo.segmentLength;
                            const totalLength = calculatePathLength([...hoverInfo.path.points, hoverInfo.path.points[0]]);
                            const area = calculatePolygonArea(hoverInfo.path.points);
                            
                            document.getElementById('segmentInfo').style.display = 'block';
                            document.getElementById('totalInfo').style.display = 'block';
                            document.getElementById('areaInfo').style.display = 'block';
                            document.getElementById('segmentDist').textContent = segmentLength.toFixed(2) + ' km';
                            document.getElementById('totalDist').textContent = totalLength.toFixed(2) + ' km';
                            document.getElementById('areaDist').textContent = area.toFixed(2) + ' km¬≤';
                        } else if (!isPolygon) {
                            const segmentLength = hoverInfo.segmentLength;
                            const totalLength = calculatePathLength(hoverInfo.path.points);
                            
                            document.getElementById('segmentInfo').style.display = 'block';
                            document.getElementById('totalInfo').style.display = 'block';
                            document.getElementById('areaInfo').style.display = 'none';
                            document.getElementById('segmentDist').textContent = segmentLength.toFixed(2) + ' km';
                            document.getElementById('totalDist').textContent = totalLength.toFixed(2) + ' km';
                        }
                        
                        tooltip.style.left = (e.clientX + 15) + 'px';
                        tooltip.style.top = (e.clientY + 15) + 'px';
                        tooltip.classList.add('show');
                        
                        redrawCanvas();
                    } else {
                        if (hoveredPath) {
                            hoveredPath = null;
                            hoveredSegment = null;
                            redrawCanvas();
                        }
                        tooltip.classList.remove('show');
                    }
                }
            
                if (isDrawingPath) {
                    redrawCanvas();
                    drawPreviewPoint(worldPos);
                }
            }
            
        function handleClick(e) {
                if (spacebarDown || isPanning || e.button !== 0) return;
                if (draggingVertex) return; // Don't process clicks while dragging
                
                const worldPos = screenToWorld(e.clientX, e.clientY);

 // Check if control-clicking a custom point
                if (e.ctrlKey || e.metaKey) {
                    const point = findCustomPointAtPosition(worldPos);
                    if (point) {
                        openEditPointModal(point);
                        return;
                    }
                }

            // Check if clicking a custom point with URL (normal click)
                if (!e.ctrlKey && !e.metaKey && !shiftKeyDown) {
                    const point = findCustomPointAtPosition(worldPos);
                    if (point && point.url) {
                        if (confirm(`Open link: ${point.url}?`)) {
                            window.open(point.url, '_blank');
                        }
                        return;
                    }
                }
                
                // Handle add-vertex tool
                if (currentTool === 'add-vertex') {
                    // Find if we clicked on a segment
                    const allPaths = [
                        ...mapData.highways,
                        ...mapData.roads,
                        ...mapData.rivers,
                        ...mapData.waterBodies,
                        ...mapData.borders,
                        ...(mapData.customPaths || [])
                    ];
                    
                    for (const path of allPaths) {
                        // Check regular segments
                        for (let i = 1; i < path.points.length; i++) {
                            const dist = distanceToSegment(worldPos, path.points[i-1], path.points[i]);
                            if (dist < 0.5) {
                                // Insert vertex at this position
                                path.points.splice(i, 0, worldPos);
                                saveToHistory();
                                redrawCanvas();
                                return;
                            }
                        }
                        
                        // For polygons, also check the closing segment
                        if (path.type === 'water' || path.type === 'border') {
                            const dist = distanceToSegment(worldPos, path.points[path.points.length - 1], path.points[0]);
                            if (dist < 0.5) {
                                // Insert at the end (which closes the polygon)
                                path.points.push(worldPos);
                                saveToHistory();
                                redrawCanvas();
                                return;
                            }
                        }
                    }
                    return;
                }
                
                // Vertex select tool doesn't do anything on click (only drag)
                if (currentTool === 'vertex-select') return;
                
                if (isEditMode && editingPath) {
                    handleEditClick(worldPos);
                } else if (extendingFromVertex !== null) {
                    extendingFromVertex.path.points.push(worldPos);
                    redrawCanvas();
                } else if (currentTool === 'city') {
                    placeCity(worldPos);
                } else if (currentTool === 'custom-point') {
 // Only add if not clicking an existing custom point
                const existing = findCustomPointAtPosition(worldPos, 1.0);
                if (!existing) {
                    placeCustomPoint(worldPos);
                }                } else {
                    if (!isDrawingPath) {
                        isDrawingPath = true;
                        currentPathPoints = [];
                        selectedPath = null;
                        updateDrawingStatus('Drawing... (double-click or Enter to finish)');
                    }
                    currentPathPoints.push(worldPos);
                    redrawCanvas();
                }
            }
            
            function handleEditClick(worldPos) {
                const vertex = findVertexAtPoint(worldPos, editingPath);
                
                if (vertex !== null) {
                    if (vertex === 0 || vertex === editingPath.points.length - 1) {
                        if (extendingFromVertex !== null) {
                            if (extendingFromVertex.vertexIndex !== vertex) {
                                joinPaths(extendingFromVertex.vertexIndex, vertex);
                            }
                            extendingFromVertex = null;
                        } else {
                            extendingFromVertex = { path: editingPath, vertexIndex: vertex };
                            updateDrawingStatus('Click to add points, click endpoint to join');
                        }
                    } else {
                        deleteVertex(vertex);
                        extendingFromVertex = null;
                    }
                } else {
                    const segment = findEditSegmentAtPoint(worldPos, editingPath);
                    if (segment !== null) {
                        deleteSegment(segment);
                        extendingFromVertex = null;
                    } else {
                        const insertInfo = findInsertionPoint(worldPos, editingPath);
                        if (insertInfo) {
                            insertVertex(insertInfo.index, worldPos);
                        }
                        extendingFromVertex = null;
                    }
                }
                
                redrawCanvas();
            }
            
            function handleDoubleClick(e) {
                e.preventDefault();
                if (spacebarDown || isPanning) return;
                
                if (extendingFromVertex !== null) {
                    extendingFromVertex = null;
                    updateDrawingStatus('Edit mode');
                    redrawCanvas();
                } else if (!isEditMode && currentTool !== 'vertex-select') {
                    finishCurrentPath();
                }
            }
            
        function handleRightClick(e) {
                e.preventDefault();
                if (isPanning || isEditMode) return;
                
                const worldPos = screenToWorld(e.clientX, e.clientY);
                
                // Check if right-clicking a custom point
                const point = findCustomPointAtPosition(worldPos);
                if (point) {
                    openEditPointModal(point);
                    return;
                }
                
                const hoverInfo = findPathAndSegmentAtPoint(worldPos);
                if (hoverInfo) {
                    selectedPath = hoverInfo.path;
                    showPathInfo(hoverInfo.path);
                    redrawCanvas();
                }
            }
                        
            function handleWheel(e) {
                e.preventDefault();
                
                const zoomChange = e.deltaY < 0 ? 0.01 : -0.01;
                const newZoom = Math.max(0.01, Math.min(50, zoomLevel + zoomChange));
                
                const offsetX = e.clientX - container.getBoundingClientRect().left;
                const offsetY = e.clientY - container.getBoundingClientRect().top;
                
                viewOffsetX = offsetX - (offsetX - viewOffsetX) * (newZoom / zoomLevel);
                viewOffsetY = offsetY - (offsetY - viewOffsetY) * (newZoom / zoomLevel);
                
                zoomLevel = newZoom;
                updateZoomDisplay();
                redrawCanvas();
            }
            
            function screenToWorld(screenX, screenY) {
                const rect = container.getBoundingClientRect();
                const x = (screenX - rect.left - viewOffsetX) / (zoomLevel * baseScale);
                const y = (screenY - rect.top - viewOffsetY) / (zoomLevel * baseScale);
                return { x, y };
            }
            
            function worldToScreen(worldX, worldY) {
                return {
                    x: worldX * baseScale * zoomLevel + viewOffsetX,
                    y: worldY * baseScale * zoomLevel + viewOffsetY
                };
            }
            
            function updateCoordinates(pos) {
                document.getElementById('coords').textContent = `${pos.x.toFixed(2)}, ${pos.y.toFixed(2)} km`;
            }
            
            function updateCursor() {
                if (spacebarDown || isPanning) {
                    return;
                }
                
                if (draggingVertex) {
                    canvas.style.cursor = 'grabbing';
                    return;
                }
                
                if (currentTool === 'vertex-select') {
                    if (hoveredVertex !== null) {
                        canvas.style.cursor = 'grab';
                    } else {
                        canvas.style.cursor = 'default';
                    }
                    return;
                }

            if (currentTool === 'add-vertex') {
                    if (hoveredSegment !== null) {
                        canvas.style.cursor = 'crosshair';
                    } else {
                        canvas.style.cursor = 'default';
                    }
                    return;
                }
                
                if (isEditMode) {
                    if (hoveredVertex !== null) {
                        canvas.style.cursor = 'move';
                    } else {
                        canvas.style.cursor = 'pointer';
                    }
            } else if (currentTool === 'city' || currentTool === 'custom-point') {
                    canvas.style.cursor = 'pointer';
                } else {
                    canvas.style.cursor = 'crosshair';
                }
            }
            
            function updateZoomDisplay() {
                const zoomPercent = Math.round(zoomLevel * 100);
                document.getElementById('zoomLevel').textContent = zoomPercent;
                document.getElementById('zoomDisplay').textContent = zoomPercent + '%';
                document.getElementById('scaleDisplay').textContent = (baseScale * zoomLevel).toFixed(2) + ' px/km';
            }
            
            function zoomIn() {
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                
                const newZoom = Math.min(50, zoomLevel + 0.01);
                viewOffsetX = centerX - (centerX - viewOffsetX) * (newZoom / zoomLevel);
                viewOffsetY = centerY - (centerY - viewOffsetY) * (newZoom / zoomLevel);
                
                zoomLevel = newZoom;
                updateZoomDisplay();
                redrawCanvas();
            }
            
            function zoomOut() {
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                
                const newZoom = Math.max(0.01, zoomLevel - 0.01);
                viewOffsetX = centerX - (centerX - viewOffsetX) * (newZoom / zoomLevel);
                viewOffsetY = centerY - (centerY - viewOffsetY) * (newZoom / zoomLevel);
                
                zoomLevel = newZoom;
                updateZoomDisplay();
                redrawCanvas();
            }
            
            function resetZoom() {
                zoomLevel = 1.0;
                viewOffsetX = 0;
                viewOffsetY = 0;
                updateZoomDisplay();
                redrawCanvas();
            }
            
            // Edit mode functions
            function enterEditMode() {
                if (!selectedPath) return;
                
                isEditMode = true;
                editingPath = selectedPath;
                extendingFromVertex = null;
                document.getElementById('editModeBanner').classList.add('active');
                document.getElementById('editModeControls').style.display = 'block';
                document.getElementById('selectedPathInfo').style.display = 'none';
                updateDrawingStatus('Edit mode');
                updateCursor();
                redrawCanvas();
            }
            
            function exitEditMode() {
                isEditMode = false;
                editingPath = null;
                hoveredVertex = null;
                hoveredEditSegment = null;
                extendingFromVertex = null;
                draggingVertex = null;
                dragVertexIndex = -1;
                dragPath = null;
                document.getElementById('editModeBanner').classList.remove('active');
                document.getElementById('editModeControls').style.display = 'none';
                updateDrawingStatus('Ready');
                updateCursor();
                saveToHistory();
                redrawCanvas();
            }
            
            function findVertexAtPoint(pos, path, tolerance = 0.5) {
                for (let i = 0; i < path.points.length; i++) {
                    const dist = calculateSegmentLength(pos, path.points[i]);
                    if (dist < tolerance) {
                        return i;
                    }
                }
                return null;
            }
            
            function findEditSegmentAtPoint(pos, path, tolerance = 0.3) {
                for (let i = 1; i < path.points.length; i++) {
                    const dist = distanceToSegment(pos, path.points[i-1], path.points[i]);
                    if (dist < tolerance) {
                        return { start: i - 1, end: i };
                    }
                }
                return null;
            }
            
            function findInsertionPoint(pos, path, tolerance = 0.5) {
                for (let i = 1; i < path.points.length; i++) {
                    const dist = distanceToSegment(pos, path.points[i-1], path.points[i]);
                    if (dist < tolerance) {
                        return { index: i, segment: { start: i-1, end: i } };
                    }
                }
                return null;
            }
            
            function deleteVertex(vertexIndex) {
                if (!editingPath || editingPath.points.length <= 2) {
                    alert('Cannot delete vertex - path must have at least 2 points');
                    return;
                }
                editingPath.points.splice(vertexIndex, 1);
            }
            
            function deleteSegment(segment) {
                if (!editingPath) return;
                
                const beforePoints = editingPath.points.slice(0, segment.start + 1);
                const afterPoints = editingPath.points.slice(segment.end);
                
                const beforeValid = beforePoints.length >= 2;
                const afterValid = afterPoints.length >= 2;
                
                if (!beforeValid && !afterValid) {
                    const collections = ['highways', 'roads', 'rivers', 'waterBodies', 'borders'];
                    for (const collection of collections) {
                        const index = mapData[collection].findIndex(p => p.id === editingPath.id);
                        if (index !== -1) {
                            mapData[collection].splice(index, 1);
                            exitEditMode();
                            return;
                        }
                    }
                } else if (beforeValid && afterValid) {
                    editingPath.points = beforePoints;
                    
                    const newPath = {
                        id: nextId++,
                        points: afterPoints,
                        type: editingPath.type
                    };
                    
                    const collection = getCollectionForType(editingPath.type);
                    mapData[collection].push(newPath);
                } else if (beforeValid) {
                    editingPath.points = beforePoints;
                } else if (afterValid) {
                    editingPath.points = afterPoints;
                }
                
                redrawCanvas();
            }
    
            function insertVertex(index, pos) {
                if (!editingPath) return;
                editingPath.points.splice(index, 0, pos);
            }
            
            function joinPaths(fromVertex, toVertex) {
                if (!editingPath) return;
                
                if (fromVertex !== 0 && fromVertex !== editingPath.points.length - 1) return;
                if (toVertex !== 0 && toVertex !== editingPath.points.length - 1) return;
                
                if (fromVertex === toVertex) {
                    return;
                }
                
                if (fromVertex === 0) {
                    editingPath.points.reverse();
                }
                
                extendingFromVertex = null;
                updateDrawingStatus('Paths joined');
            }
            
            function getCollectionForType(type) {
                switch(type) {
                    case 'highway': return 'highways';
                    case 'road': return 'roads';
                    case 'river': return 'rivers';
                    case 'water': return 'waterBodies';
                    case 'border': return 'borders';
                    default:
                        // Check if it's a custom path tool
                        if (type && type.startsWith('custom-path-')) {
                            return 'customPaths';
                        }
                        return 'highways';
                }
            }
            
            function setTool(tool, buttonElement) {
                if (isEditMode) {
                    exitEditMode();
                }
                
                if (isDrawingPath && tool !== currentTool) {
                    finishCurrentPath();
                }
    
                currentTool = tool;
                
                // Clear any dragging state when switching tools
                draggingVertex = null;
                dragVertexIndex = -1;
                dragPath = null;
                hoveredVertex = null;
                hoveredPath = null;
                
                document.querySelectorAll('.tool-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                buttonElement.classList.add('active');
    
            const toolNames = {
                    'highway': 'Highway',
                    'road': 'Road',
                    'river': 'River',
                    'water': 'Water Body',
                    'border': 'Border',
                    'city': 'City',
                    'vertex-select': 'Vertex Select',
                    'add-vertex': 'Add Vertex',
                    'custom-point': 'Custom Point'
                };
                
                let toolDisplayName = toolNames[tool];
                
                // Check if it's a custom path tool
                if (!toolDisplayName && tool && tool.startsWith('custom-path-')) {
                    const customTool = getCustomPathToolById(tool);
                    if (customTool) {
                        toolDisplayName = customTool.name;
                    }
                }
                
                document.getElementById('currentToolDisplay').textContent = toolDisplayName || tool;
    
                updateCursor();
                updateDrawingStatus('Ready');
                redrawCanvas();
            }
    
            function updateDrawingStatus(status) {
                document.getElementById('drawingStatus').textContent = status;
            }
    
            function finishCurrentPath() {
                if (!isDrawingPath || currentPathPoints.length < 2) {
                    isDrawingPath = false;
                    currentPathPoints = [];
                    updateDrawingStatus('Ready');
                    return;
                }
    
                const pathData = {
                    id: nextId++,
                    points: [...currentPathPoints],
                    type: currentTool
                };
    
                const collection = getCollectionForType(currentTool);
                mapData[collection].push(pathData);
    
                isDrawingPath = false;
                currentPathPoints = [];
                saveToHistory();
                redrawCanvas();
                updateDrawingStatus('Ready');
            }
    
            function cancelCurrentPath() {
                isDrawingPath = false;
                currentPathPoints = [];
                redrawCanvas();
                updateDrawingStatus('Ready');
            }
    
            function placeCity(pos) {
                const cityName = document.getElementById('cityName').value || 'Unnamed City';
                
                mapData.cities.push({
                    id: nextId++,
                    name: cityName,
                    x: pos.x,
                    y: pos.y
                });
    
                saveToHistory();
                redrawCanvas();
            }
    
        function placeCustomPoint(pos) {
                const iconClass = document.getElementById('customIcon').value.trim();
                
                if (!iconClass) {
                    alert('Please enter a Font Awesome icon class (e.g., "tree", "hospital", "star")');
                    return;
                }
                
                const label = document.getElementById('customLabel').value || '';
                const url = document.getElementById('customURL').value || '';
                
                mapData.customPoints.push({
                    id: nextId++,
                    x: pos.x,
                    y: pos.y,
                    icon: iconClass,
                    label: label,
                    url: url
                });
            
                saveToHistory();
                redrawCanvas();
            }

            // Custom Path Tool Management
            function openAddCustomPathToolDialog() {
                document.getElementById('addCustomPathToolDialog').style.display = 'block';
            }
            
            function closeAddCustomPathToolDialog() {
                document.getElementById('addCustomPathToolDialog').style.display = 'none';
                document.getElementById('customPathToolName').value = '';
                document.getElementById('customPathThickness').value = '4';
                document.getElementById('customPathColor').value = '#8e44ad';
                document.getElementById('customPathStyle').value = 'solid';
            }
            
            function addCustomPathTool() {
                const name = document.getElementById('customPathToolName').value.trim();
                const thickness = parseInt(document.getElementById('customPathThickness').value);
                const color = document.getElementById('customPathColor').value;
                const style = document.getElementById('customPathStyle').value;
                
                if (!name) {
                    alert('Please enter a tool name');
                    return;
                }
                
                if (!thickness || thickness < 1 || thickness > 20) {
                    alert('Please enter a valid thickness between 1 and 20');
                    return;
                }
                
                // Generate a unique ID for this tool
                const toolId = 'custom-path-' + Date.now();
                
                // Add to custom tools array
                customPathTools.push({
                    id: toolId,
                    name: name,
                    thickness: thickness,
                    color: color,
                    style: style
                });
                
                // Initialize the collection for this tool in mapData
                if (!mapData.customPaths) {
                    mapData.customPaths = [];
                }
                
                // Create button for the tool
                renderCustomPathToolButtons();
                
                closeAddCustomPathToolDialog();
                saveToHistory();
            }
            
            function renderCustomPathToolButtons() {
                const container = document.getElementById('customPathToolsContainer');
                container.innerHTML = '';
                
                customPathTools.forEach(tool => {
                    const button = document.createElement('button');
                    button.className = 'tool-btn';
                    button.onclick = function() { setTool(tool.id, this); };
                    button.textContent = tool.name;
                    button.style.borderLeft = `6px solid ${tool.color}`;
                    container.appendChild(button);
                });
            }
            
            function getCustomPathToolById(toolId) {
                return customPathTools.find(tool => tool.id === toolId);
            }


        function findCustomPointAtPosition(pos, tolerance = 1.0) {
                for (const point of mapData.customPoints) {
                    const dist = calculateSegmentLength(pos, { x: point.x, y: point.y });
                    if (dist < tolerance) {
                        return point;
                    }
                }
                return null;
            }
            
            function openEditPointModal(point) {
                editingPoint = point;
                document.getElementById('editIcon').value = point.icon;
                document.getElementById('editLabel').value = point.label || '';
                document.getElementById('editURL').value = point.url || '';
                document.getElementById('editPointModal').style.display = 'flex';
            }
            
            function closeEditModal() {
                editingPoint = null;
                document.getElementById('editPointModal').style.display = 'none';
            }
            
            function savePointEdit() {
                if (!editingPoint) return;
                
                editingPoint.icon = document.getElementById('editIcon').value.trim();
                editingPoint.label = document.getElementById('editLabel').value.trim();
                editingPoint.url = document.getElementById('editURL').value.trim();
                
                // Reload the icon if changed
                const iconKey = editingPoint.icon.toLowerCase().replace(/^fa-/, '').replace('fa-', '');
                if (!svgIconCache[iconKey]) {
                    loadSVGIcon(iconKey);
                }
                
                closeEditModal();
                saveToHistory();
                redrawCanvas();
            }
            
            function deletePointFromModal() {
                if (!editingPoint) return;
                
                if (confirm('Delete this custom point?')) {
                    const index = mapData.customPoints.findIndex(p => p.id === editingPoint.id);
                    if (index !== -1) {
                        mapData.customPoints.splice(index, 1);
                    }
                    closeEditModal();
                    saveToHistory();
                    redrawCanvas();
                }
            }

            function calculatePathLength(points) {
                let totalLength = 0;
                for (let i = 1; i < points.length; i++) {
                    totalLength += calculateSegmentLength(points[i-1], points[i]);
                }
                return totalLength;
            }
    
            function calculateSegmentLength(p1, p2) {
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                return Math.sqrt(dx * dx + dy * dy);
            }
    
            function calculatePolygonArea(points) {
                if (points.length < 3) return 0;
                
                let area = 0;
                for (let i = 0; i < points.length; i++) {
                    const j = (i + 1) % points.length;
                    area += points[i].x * points[j].y;
                    area -= points[j].x * points[i].y;
                }
                return Math.abs(area / 2);
            }
    
            function findPathAndSegmentAtPoint(pos, tolerance = 0.5) {
                const allPaths = [
                    ...mapData.borders.map(p => ({...p, collection: 'borders'})),
                    ...mapData.highways.map(p => ({...p, collection: 'highways'})),
                    ...mapData.roads.map(p => ({...p, collection: 'roads'})),
                    ...mapData.rivers.map(p => ({...p, collection: 'rivers'})),
                    ...mapData.waterBodies.map(p => ({...p, collection: 'waterBodies'})),
                    ...(mapData.customPaths || []).map(p => ({...p, collection: 'customPaths'}))
                ].reverse();
    
                for (const path of allPaths) {
                    for (let i = 1; i < path.points.length; i++) {
                        const dist = distanceToSegment(pos, path.points[i-1], path.points[i]);
                        if (dist < tolerance) {
                            return {
                                path: path,
                                segment: { start: i - 1, end: i },
                                segmentLength: calculateSegmentLength(path.points[i-1], path.points[i])
                            };
                        }
                    }
                    
                    if (path.type === 'water' || path.type === 'border') {
                        const dist = distanceToSegment(pos, path.points[path.points.length - 1], path.points[0]);
                        if (dist < tolerance) {
                            return {
                                path: path,
                                segment: { start: path.points.length - 1, end: 0 },
                                segmentLength: calculateSegmentLength(path.points[path.points.length - 1], path.points[0])
                            };
                        }
                    }
                }
                return null;
            }
    
            function distanceToSegment(point, segStart, segEnd) {
                const dx = segEnd.x - segStart.x;
                const dy = segEnd.y - segStart.y;
                const lengthSquared = dx * dx + dy * dy;
                
                if (lengthSquared === 0) {
                    return calculateSegmentLength(point, segStart);
                }
                
                const t = Math.max(0, Math.min(1, 
                    ((point.x - segStart.x) * dx + (point.y - segStart.y) * dy) / lengthSquared
                ));
                
                const projX = segStart.x + t * dx;
                const projY = segStart.y + t * dy;
                
                return calculateSegmentLength(point, { x: projX, y: projY });
            }
    
            function showPathInfo(path) {
                const isPolygon = path.type === 'water' || path.type === 'border';
                
                if (isPolygon) {
                    const area = calculatePolygonArea(path.points);
                    const perimeter = calculatePathLength([...path.points, path.points[0]]);
                    document.getElementById('selectedDistance').textContent = perimeter.toFixed(2) + ' (perimeter)';
                    document.getElementById('selectedArea').textContent = area.toFixed(2);
                    document.getElementById('areaDisplay').style.display = 'block';
                } else {
                    const length = calculatePathLength(path.points);
                    document.getElementById('selectedDistance').textContent = length.toFixed(2);
                    document.getElementById('areaDisplay').style.display = 'none';
                }
                
                document.getElementById('selectedType').textContent = path.type.charAt(0).toUpperCase() + path.type.slice(1);
                document.getElementById('selectedPoints').textContent = path.points.length;
                document.getElementById('selectedPathInfo').style.display = 'block';
            }
    
            function deleteSelected() {
                if (!selectedPath) return;
    
                if (!confirm('Delete this entire path?')) return;
    
                const collections = ['highways', 'roads', 'rivers', 'waterBodies', 'borders'];
                for (const collection of collections) {
                    const index = mapData[collection].findIndex(p => p.id === selectedPath.id);
                    if (index !== -1) {
                        mapData[collection].splice(index, 1);
                        break;
                    }
                }
    
                selectedPath = null;
                document.getElementById('selectedPathInfo').style.display = 'none';
                saveToHistory();
                redrawCanvas();
            }
    
            function drawPreviewPoint(pos) {
                if (currentPathPoints.length === 0) return;
    
                const lastPoint = currentPathPoints[currentPathPoints.length - 1];
                const lastScreen = worldToScreen(lastPoint.x, lastPoint.y);
                const posScreen = worldToScreen(pos.x, pos.y);
                
                ctx.save();
                ctx.setLineDash([5, 5]);
                ctx.strokeStyle = '#95a5a6';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(lastScreen.x, lastScreen.y);
                ctx.lineTo(posScreen.x, posScreen.y);
                ctx.stroke();
                ctx.restore();
    
                const dist = calculateSegmentLength(lastPoint, pos);
                const midX = (lastScreen.x + posScreen.x) / 2;
                const midY = (lastScreen.y + posScreen.y) / 2;
    
                ctx.fillStyle = '#2c3e50';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${dist.toFixed(2)} km`, midX, midY - 5);
            }
    
            function drawExtensionPreview(pos) {
                if (!extendingFromVertex) return;
    
                const lastPoint = extendingFromVertex.path.points[extendingFromVertex.vertexIndex];
                const lastScreen = worldToScreen(lastPoint.x, lastPoint.y);
                const posScreen = worldToScreen(pos.x, pos.y);
                
                ctx.save();
                ctx.setLineDash([5, 5]);
                ctx.strokeStyle = '#e74c3c';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(lastScreen.x, lastScreen.y);
                ctx.lineTo(posScreen.x, posScreen.y);
                ctx.stroke();
                ctx.restore();
    
                const dist = calculateSegmentLength(lastPoint, pos);
                const midX = (lastScreen.x + posScreen.x) / 2;
                const midY = (lastScreen.y + posScreen.y) / 2;
    
                ctx.fillStyle = '#e74c3c';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${dist.toFixed(2)} km`, midX, midY - 5);
            }
    
            function clearCanvas() {
                if (confirm('Are you sure you want to clear the entire map?')) {
                    mapData = {
                        highways: [],
                        roads: [],
                        rivers: [],
                        waterBodies: [],
                        borders: [],
                        cities: [],
                        customPoints: []
                    };
                    history = [];
                    selectedPath = null;
                    isDrawingPath = false;
                    currentPathPoints = [];
                    isEditMode = false;
                    editingPath = null;
                    extendingFromVertex = null;
                    draggingVertex = null;
                    dragVertexIndex = -1;
                    dragPath = null;
                    document.getElementById('selectedPathInfo').style.display = 'none';
                    document.getElementById('editModeControls').style.display = 'none';
                    document.getElementById('editModeBanner').classList.remove('active');
                    saveToHistory();
                    redrawCanvas();
                }
            }
    
            function saveToHistory() {
                history.push(JSON.parse(JSON.stringify(mapData)));
                if (history.length > 50) {
                    history.shift();
                }
            }
    
            function undo() {
                if (history.length > 1) {
                    history.pop();
                    mapData = JSON.parse(JSON.stringify(history[history.length - 1]));
                    selectedPath = null;
                    isEditMode = false;
                    editingPath = null;
                    extendingFromVertex = null;
                    draggingVertex = null;
                    dragVertexIndex = -1;
                    dragPath = null;
                    document.getElementById('selectedPathInfo').style.display = 'none';
                    document.getElementById('editModeControls').style.display = 'none';
                    document.getElementById('editModeBanner').classList.remove('active');
                    redrawCanvas();
                }
            }
    
            function exportMap() {
                const link = document.createElement('a');
                link.download = 'map-design.png';
                link.href = canvas.toDataURL('image/png');
                link.click();
            }
    
            function exportJSON() {
                // Create export data that includes both the map data and custom path tool definitions
                const exportData = {
                    ...mapData,
                    customPathToolDefinitions: customPathTools
                };
                const dataStr = JSON.stringify(exportData, null, 2);
                const blob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.download = 'map-data.json';
                link.href = url;
                link.click();
                URL.revokeObjectURL(url);
            }
    
    function updateSVGPath() {
        const newPath = document.getElementById('svgPath').value;
        if (newPath) {
            svgBasePath = newPath;
            // Clear cache and reload
            svgIconCache = {};
            preloadCommonIcons();
            redrawCanvas();
        }
    }
    
    function importJSON() {
        // Trigger the hidden file input
        document.getElementById('jsonFileInput').click();
    }
    
    function handleFileImport(event) {
        const file = event.target.files[0];
        if (!file) return;
    
        // Check if it's a JSON file
        if (!file.name.endsWith('.json')) {
            alert('Please select a valid JSON file');
            event.target.value = ''; // Reset input
            return;
        }
    
        const reader = new FileReader();
        
        reader.onload = function(e) {
            try {
                const importedData = JSON.parse(e.target.result);
                
                // Validate the imported data structure
                if (!importedData || typeof importedData !== 'object') {
                    throw new Error('Invalid JSON structure');
                }
    
                    // Check if it has the expected map data structure
                const requiredFields = ['highways', 'roads', 'rivers', 'waterBodies', 'borders', 'cities'];
                const hasValidStructure = requiredFields.every(field => 
                    Array.isArray(importedData[field])
                );
                
                // Handle customPoints for backward compatibility
                if (!importedData.customPoints) {
                    importedData.customPoints = [];
                }
                    
                if (!hasValidStructure) {
                    throw new Error('JSON file does not contain valid map data');
                }
    
                // Confirm before importing
                const totalItems = 
                    importedData.highways.length +
                    importedData.roads.length +
                    importedData.rivers.length +
                    importedData.waterBodies.length +
                    importedData.borders.length +
                    importedData.cities.length;
    
                    const confirmMessage = `Import map with:\n` +
                    `‚Ä¢ ${importedData.highways.length} highways\n` +
                    `‚Ä¢ ${importedData.roads.length} roads\n` +
                    `‚Ä¢ ${importedData.rivers.length} rivers\n` +
                    `‚Ä¢ ${importedData.waterBodies.length} water bodies\n` +
                    `‚Ä¢ ${importedData.borders.length} borders\n` +
                    `‚Ä¢ ${importedData.cities.length} cities\n` +
                    `‚Ä¢ ${importedData.customPoints?.length || 0} custom points\n\n` +
                    `This will replace your current map. Continue?`;
                        
                if (!confirm(confirmMessage)) {
                    event.target.value = ''; // Reset input
                    return;
                }
    
                // Update nextId to avoid ID conflicts
                let maxId = 0;
                [...importedData.highways, ...importedData.roads, ...importedData.rivers, 
                 ...importedData.waterBodies, ...importedData.borders, ...importedData.cities].forEach(item => {
                    if (item.id && item.id > maxId) {
                        maxId = item.id;
                    }
                });
                nextId = maxId + 1;
    
                // Import the data
                mapData = importedData;
                
                // If the imported data contains custom path tool definitions, restore them
                if (importedData.customPathToolDefinitions) {
                    customPathTools = importedData.customPathToolDefinitions;
                    renderCustomPathToolButtons();
                }
                
                // Clear any active editing states
                isDrawingPath = false;
                currentPathPoints = [];
                selectedPath = null;
                isEditMode = false;
                editingPath = null;
                extendingFromVertex = null;
                draggingVertex = null;
                dragVertexIndex = -1;
                dragPath = null;
                hoveredVertex = null;
                hoveredPath = null;
                hoveredSegment = null;
                
                // Hide any open panels
                document.getElementById('selectedPathInfo').style.display = 'none';
                document.getElementById('editModeControls').style.display = 'none';
                document.getElementById('editModeBanner').classList.remove('active');
                
                // Save to history and redraw
                history = [];
                saveToHistory();
                updateDrawingStatus('Map imported successfully');
                redrawCanvas();
                
                // Center and zoom to fit the imported map
                setTimeout(() => {
                    fitMapToView();
                }, 100);
    
                alert('Map imported successfully!');
    
            } catch (error) {
                console.error('Import error:', error);
                alert('Error importing JSON file: ' + error.message + '\n\nPlease make sure you are importing a valid map data file.');
            }
            
            // Reset the file input so the same file can be imported again
            event.target.value = '';
        };
    
        reader.onerror = function() {
            alert('Error reading file. Please try again.');
            event.target.value = '';
        };
    
        reader.readAsText(file);
    }
    
    function fitMapToView() {
        const bounds = calculateMapBounds();
        
        // Check if map is empty
        if (bounds.minX === Infinity) {
            resetZoom();
            return;
        }
    
        const mapWidth = bounds.maxX - bounds.minX;
        const mapHeight = bounds.maxY - bounds.minY;
        
        if (mapWidth === 0 || mapHeight === 0) {
            resetZoom();
            return;
        }
    
        // Calculate zoom to fit
        const padding = 50; // pixels of padding
        const availableWidth = canvas.width - padding * 2;
        const availableHeight = canvas.height - padding * 2;
        
        const zoomX = availableWidth / (mapWidth * baseScale);
        const zoomY = availableHeight / (mapHeight * baseScale);
        
        zoomLevel = Math.min(zoomX, zoomY, 5); // Cap at 5x zoom
        
        // Calculate center offset
        const mapCenterX = (bounds.minX + bounds.maxX) / 2;
        const mapCenterY = (bounds.minY + bounds.maxY) / 2;
        
        viewOffsetX = canvas.width / 2 - mapCenterX * baseScale * zoomLevel;
        viewOffsetY = canvas.height / 2 - mapCenterY * baseScale * zoomLevel;
        
        updateZoomDisplay();
        redrawCanvas();
    }
    
    
    
            function redrawCanvas() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#f8f9fa';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
    
                drawGrid();
    
                drawAllPolygons(mapData.waterBodies);
                drawAllPaths(mapData.rivers, 'river');
                drawAllPaths(mapData.roads, 'road');
                drawAllPaths(mapData.highways, 'highway');
                drawAllPolygons(mapData.borders, true);
                
                // Draw custom paths
                if (mapData.customPaths && mapData.customPaths.length > 0) {
                    mapData.customPaths.forEach(path => {
                        drawPath(path.points, path.type, false, false);
                    });
                }
    
                mapData.cities.forEach(city => drawCity(city));
                mapData.customPoints.forEach(point => drawCustomPoint(point));
    
                if (isDrawingPath && currentPathPoints.length > 0) {
                    drawPath(currentPathPoints, currentTool, false, true);
                }
    
                if (selectedPath && !isEditMode) {
                    if (selectedPath.type === 'water' || selectedPath.type === 'border') {
                        drawPolygon(selectedPath.points, true, selectedPath.type === 'border');
                    } else {
                        drawPath(selectedPath.points, selectedPath.type, true, false);
                    }
                }
    
                if (isEditMode && editingPath) {
                    if (editingPath.type === 'water' || editingPath.type === 'border') {
                        drawPolygon(editingPath.points, true, editingPath.type === 'border', true);
                    } else {
                        drawPath(editingPath.points, editingPath.type, true, false, true);
                    }
                }
                
                // Highlight hovered vertex when using vertex select tool
                if (currentTool === 'vertex-select' && hoveredPath && hoveredVertex !== null && !draggingVertex) {
                    const point = hoveredPath.points[hoveredVertex];
                    const screenPoint = worldToScreen(point.x, point.y);
                    
                    ctx.save();
                    ctx.beginPath();
                    ctx.arc(screenPoint.x, screenPoint.y, 12, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(231, 76, 60, 0.5)';
                    ctx.fill();
                    ctx.strokeStyle = '#e74c3c';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    ctx.restore();
                }
                
                // Show insertion preview when using add-vertex tool
                if (currentTool === 'add-vertex' && hoveredPath && hoveredSegment) {
                    const seg = hoveredSegment;
                    const points = hoveredPath.points;
                    
                    if (seg.end === 0) {
                        drawPathSegment(points[seg.start], points[0], hoveredPath.type, true);
                    } else {
                        drawPathSegment(points[seg.start], points[seg.end], hoveredPath.type, true);
                    }
                    
                    // Get mouse position to show where vertex will be inserted
                    const rect = container.getBoundingClientRect();
                    if (lastMouseX !== undefined && lastMouseY !== undefined) {
                        const worldPos = screenToWorld(lastMouseX, lastMouseY);
                        const screenPos = worldToScreen(worldPos.x, worldPos.y);
                        
                        ctx.save();
                        ctx.beginPath();
                        ctx.arc(screenPos.x, screenPos.y, 8, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(46, 204, 113, 0.6)';
                        ctx.fill();
                        ctx.strokeStyle = '#2ecc71';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        ctx.restore();
                    }
                }
    
                if (hoveredPath && hoveredPath !== selectedPath && hoveredSegment && !isEditMode) {
                    const points = hoveredPath.points;
                    const seg = hoveredSegment;
                    if (seg.end === 0) {
                        drawPathSegment(points[seg.start], points[0], hoveredPath.type, true);
                    } else {
                        drawPathSegment(points[seg.start], points[seg.end], hoveredPath.type, true);
                    }
                }
            }
    
            function drawGrid() {
                ctx.save();
                ctx.strokeStyle = '#e0e0e0';
                ctx.lineWidth = 1;
    
                const gridSpacing = 10;
    
                const topLeft = screenToWorld(0, 0);
                const bottomRight = screenToWorld(canvas.width, canvas.height);
    
                const startX = Math.floor(topLeft.x / gridSpacing) * gridSpacing;
                const endX = Math.ceil(bottomRight.x / gridSpacing) * gridSpacing;
                for (let x = startX; x <= endX; x += gridSpacing) {
                    const screenPos = worldToScreen(x, 0);
                    ctx.beginPath();
                    ctx.moveTo(screenPos.x, 0);
                    ctx.lineTo(screenPos.x, canvas.height);
                    ctx.stroke();
                }
    
                const startY = Math.floor(topLeft.y / gridSpacing) * gridSpacing;
                const endY = Math.ceil(bottomRight.y / gridSpacing) * gridSpacing;
                for (let y = startY; y <= endY; y += gridSpacing) {
                    const screenPos = worldToScreen(0, y);
                    ctx.beginPath();
                    ctx.moveTo(0, screenPos.y);
                    ctx.lineTo(canvas.width, screenPos.y);
                    ctx.stroke();
                }
    
                if (zoomLevel > 0.3) {
                    ctx.fillStyle = '#bdc3c7';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'left';
    
                    for (let x = startX; x <= endX; x += gridSpacing) {
                        if (x === 0) continue;
                        const screenPos = worldToScreen(x, Math.max(topLeft.y, 0));
                        ctx.fillText(`${x}km`, screenPos.x + 2, screenPos.y + 12);
                    }
    
                    for (let y = startY; y <= endY; y += gridSpacing) {
                        if (y === 0) continue;
                        const screenPos = worldToScreen(Math.max(topLeft.x, 0), y);
                        ctx.fillText(`${y}km`, screenPos.x + 2, screenPos.y + 12);
                    }
                }
    
                ctx.restore();
            }
    
            function drawAllPaths(paths, type) {
                paths.forEach(path => {
                    drawPath(path.points, type, false, false);
                });
            }
    
            function drawAllPolygons(polygons, isBorder = false) {
                polygons.forEach(polygon => {
                    drawPolygon(polygon.points, false, isBorder);
                });
            }
    
            function drawPolygon(points, isSelected = false, isBorder = false, isEditing = false) {
                if (points.length < 3) return;
    
                ctx.save();
    
                ctx.beginPath();
                const firstPoint = worldToScreen(points[0].x, points[0].y);
                ctx.moveTo(firstPoint.x, firstPoint.y);
                
                for (let i = 1; i < points.length; i++) {
                    const point = worldToScreen(points[i].x, points[i].y);
                    ctx.lineTo(point.x, point.y);
                }
                ctx.closePath();
    
                if (isBorder) {
                    ctx.strokeStyle = '#34495e';
                    ctx.lineWidth = isSelected ? 5 : 3;
                    ctx.setLineDash([10, 5]);
                } else {
                    ctx.fillStyle = 'rgba(52, 152, 219, 0.4)';
                    ctx.fill();
                    ctx.strokeStyle = '#3498db';
                    ctx.lineWidth = isSelected ? 4 : 2;
                }
    
                if (isSelected) {
                    ctx.shadowColor = '#f39c12';
                    ctx.shadowBlur = 10;
                }
                ctx.stroke();
    
                points.forEach((point, index) => {
                    const screenPoint = worldToScreen(point.x, point.y);
                    const isHovered = isEditing && hoveredVertex === index;
                    const isEndpoint = index === 0 || index === points.length - 1;
                    const vertexRadius = isEditing ? 8 : (isSelected ? 5 : 3);
                    
                    ctx.beginPath();
                    ctx.arc(screenPoint.x, screenPoint.y, isHovered ? vertexRadius + 2 : vertexRadius, 0, Math.PI * 2);
                    
                    if (isHovered) {
                        ctx.fillStyle = '#e74c3c';
                    } else if (isEditing && isEndpoint) {
                        ctx.fillStyle = '#2ecc71';
                    } else if (isSelected) {
                        ctx.fillStyle = '#f39c12';
                    } else {
                        ctx.fillStyle = '#2c3e50';
                    }
                    
                    ctx.fill();
                });
    
                if (isEditing && hoveredEditSegment) {
                    const seg = hoveredEditSegment;
                    drawPathSegment(points[seg.start], points[seg.end], isBorder ? 'border' : 'water', true);
                }
    
                ctx.restore();
            }
    
            function drawPath(points, type, isSelected = false, isCurrent = false, isEditing = false) {
                if (points.length < 1) return;
    
                ctx.save();
    
                setDrawStyle(type);
    
                if (isSelected) {
                    ctx.lineWidth += 4;
                    ctx.shadowColor = '#f39c12';
                    ctx.shadowBlur = 10;
                }
    
                if (points.length === 1) {
                    const screenPoint = worldToScreen(points[0].x, points[0].y);
                    ctx.beginPath();
                    ctx.arc(screenPoint.x, screenPoint.y, 3, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    ctx.beginPath();
                    const firstPoint = worldToScreen(points[0].x, points[0].y);
                    ctx.moveTo(firstPoint.x, firstPoint.y);
                    
                    for (let i = 1; i < points.length; i++) {
                        const point = worldToScreen(points[i].x, points[i].y);
                        ctx.lineTo(point.x, point.y);
                    }
                    ctx.stroke();
                }
    
                ctx.globalAlpha = 1;
                
                points.forEach((point, index) => {
                    const screenPoint = worldToScreen(point.x, point.y);
                    const isHovered = isEditing && hoveredVertex === index;
                    const isEndpoint = index === 0 || index === points.length - 1;
                    const isExtending = extendingFromVertex && extendingFromVertex.vertexIndex === index;
                    const vertexRadius = isEditing ? 8 : (isSelected ? 5 : 3);
                    
                    ctx.beginPath();
                    ctx.arc(screenPoint.x, screenPoint.y, isHovered ? vertexRadius + 2 : vertexRadius, 0, Math.PI * 2);
                    
                    if (isExtending) {
                        ctx.fillStyle = '#e74c3c';
                    } else if (isHovered) {
                        ctx.fillStyle = '#e74c3c';
                    } else if (isEditing && isEndpoint) {
                        ctx.fillStyle = '#2ecc71';
                    } else if (isSelected) {
                        ctx.fillStyle = '#f39c12';
                    } else {
                        ctx.fillStyle = '#2c3e50';
                    }
                    
                    ctx.fill();
                });
    
                if (isEditing && hoveredEditSegment) {
                    const seg = hoveredEditSegment;
                    drawPathSegment(points[seg.start], points[seg.end], type, true);
                }
    
                if ((isSelected || isCurrent) && zoomLevel > 0.3) {
                    ctx.font = '11px Arial';
                    ctx.textAlign = 'center';
                    
                    for (let i = 1; i < points.length; i++) {
                        const dist = calculateSegmentLength(points[i-1], points[i]);
                        const midWorld = {
                            x: (points[i-1].x + points[i].x) / 2,
                            y: (points[i-1].y + points[i].y) / 2
                        };
                        const midScreen = worldToScreen(midWorld.x, midWorld.y);
                        
                        ctx.save();
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                        ctx.fillRect(midScreen.x - 25, midScreen.y - 10, 50, 15);
                        ctx.restore();
                        
                        ctx.fillStyle = '#e74c3c';
                        ctx.fillText(`${dist.toFixed(2)} km`, midScreen.x, midScreen.y);
                    }
                }
    
                ctx.restore();
            }
    
            function drawPathSegment(p1, p2, type, isHighlighted = false) {
                ctx.save();
                
                setDrawStyle(type);
                
                if (isHighlighted) {
                    ctx.lineWidth += 3;
                    ctx.shadowColor = '#f39c12';
                    ctx.shadowBlur = 8;
                }
    
                const screen1 = worldToScreen(p1.x, p1.y);
                const screen2 = worldToScreen(p2.x, p2.y);
    
                ctx.beginPath();
                ctx.moveTo(screen1.x, screen1.y);
                ctx.lineTo(screen2.x, screen2.y);
                ctx.stroke();
    
                ctx.restore();
            }
    
            function setDrawStyle(type) {
                ctx.globalAlpha = 1;
                ctx.setLineDash([]);
                
                switch(type) {
                    case 'highway':
                        ctx.strokeStyle = '#e74c3c';
                        ctx.lineWidth = 8;
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';
                        break;
                    case 'road':
                        ctx.strokeStyle = '#95a5a6';
                        ctx.lineWidth = 4;
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';
                        break;
                    case 'river':
                        ctx.strokeStyle = '#3498db';
                        ctx.lineWidth = 6;
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';
                        break;
                    case 'border':
                        ctx.strokeStyle = '#34495e';
                        ctx.lineWidth = 3;
                        ctx.setLineDash([10, 5]);
                        ctx.lineCap = 'butt';
                        ctx.lineJoin = 'miter';
                        break;
                    case 'water':
                        ctx.strokeStyle = '#3498db';
                        ctx.lineWidth = 2;
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';
                        break;
                    default:
                        // Check if it's a custom path tool
                        if (type && type.startsWith('custom-path-')) {
                            const customTool = getCustomPathToolById(type);
                            if (customTool) {
                                ctx.strokeStyle = customTool.color;
                                ctx.lineWidth = customTool.thickness;
                                ctx.lineCap = 'round';
                                ctx.lineJoin = 'round';
                                
                                // Apply path style
                                switch(customTool.style) {
                                    case 'dashed':
                                        ctx.setLineDash([10, 5]);
                                        break;
                                    case 'dotted':
                                        ctx.setLineDash([2, 3]);
                                        break;
                                    case 'solid':
                                    default:
                                        ctx.setLineDash([]);
                                        break;
                                }
                            }
                        }
                        break;
                }
            }
    
            function drawCity(city) {
                const screenPos = worldToScreen(city.x, city.y);
    
                ctx.save();
                ctx.globalAlpha = 1;
                ctx.fillStyle = '#f39c12';
                ctx.beginPath();
                ctx.arc(screenPos.x, screenPos.y, 8, 0, Math.PI * 2);
                ctx.fill();
    
                ctx.strokeStyle = '#e67e22';
                ctx.lineWidth = 2;
                ctx.stroke();
    
                if (zoomLevel > 0.3) {
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(city.name, screenPos.x, screenPos.y - 12);
                }
                ctx.restore();
            }
            

        function drawCustomPoint(point) {
                const screenPos = worldToScreen(point.x, point.y);
            
                ctx.save();
                ctx.globalAlpha = 1;
                
                // Draw a background circle
                ctx.fillStyle = point.url ? '#3498db' : '#9b59b6'; // Blue if has URL
                ctx.beginPath();
                ctx.arc(screenPos.x, screenPos.y, 14, 0, Math.PI * 2);
                ctx.fill();
            
                ctx.strokeStyle = point.url ? '#2980b9' : '#8e44ad';
                ctx.lineWidth = 2;
                ctx.stroke();
            
                // Draw the SVG icon
                const iconKey = point.icon.toLowerCase().replace(/^fa-/, '').replace('fa-', '');
                if (svgIconCache[iconKey]) {
                    const img = svgIconCache[iconKey];
                    if (img.complete && img.naturalWidth > 0) {
                        // Draw the icon centered and scaled
                        const iconSize = 16;
                        ctx.drawImage(img, screenPos.x - iconSize/2, screenPos.y - iconSize/2, iconSize, iconSize);
                    } else {
                        // Fallback while loading
                        drawFallbackIcon(ctx, screenPos.x, screenPos.y);
                    }
                } else {
                    // Try to load the icon
                    loadSVGIcon(iconKey);
                    drawFallbackIcon(ctx, screenPos.x, screenPos.y);
                }
            
                // Draw label if present
                if (point.label && zoomLevel > 0.3) {
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    ctx.fillText(point.label, screenPos.x, screenPos.y + 18);
                }
                
                // Show link indicator
                if (point.url && zoomLevel > 0.5) {
                    ctx.fillStyle = '#3498db';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    ctx.fillText('üîó', screenPos.x + 12, screenPos.y - 12);
                }
                
                ctx.restore();
            }

        function loadSVGIcon(iconName) {
            if (svgIconCache[iconName]) return;
            
            // Create a new Image object
            const img = new Image();
            
            // Convert SVG to data URL with white color
            const svgPath = `${svgBasePath}${iconName}.svg`;
            
            // Load the SVG
            fetch(svgPath)
                .then(response => {
                    if (!response.ok) {
                        // Try solid folder if regular doesn't exist
                        return fetch(svgPath.replace('/regular/', '/solid/'));
                    }
                    return response;
                })
                .then(response => response.text())
                .then(svgText => {
                    // Modify SVG to be white and add proper sizing
                    let modifiedSvg = svgText
                        .replace(/<svg/, '<svg fill="white"')
                        .replace(/fill="[^"]*"/g, 'fill="white"')
                        .replace(/stroke="[^"]*"/g, 'stroke="white"');
                    
                    // Convert to data URL
                    const blob = new Blob([modifiedSvg], { type: 'image/svg+xml' });
                    const url = URL.createObjectURL(blob);
                    
                    img.onload = function() {
                        URL.revokeObjectURL(url);
                        redrawCanvas();
                    };
                    
                    img.src = url;
                    svgIconCache[iconName] = img;
                })
                .catch(error => {
                    console.warn(`Could not load icon: ${iconName}`, error);
                    // Use a default icon
                    svgIconCache[iconName] = null;
                });
        }


        function preloadCommonIcons() {
            const commonIcons = [
                'tree', 'mountain', 'hospital', 'star', 'flag', 'home', 
                'building', 'church', 'mosque', 'landmark', 'bridge', 
                'anchor', 'plane', 'train', 'ship', 'fire', 'heart',
                'circle', 'square', 'campground', 'industry', 'gas-pump',
                'utensils', 'coffee', 'hotel', 'shopping-cart', 'plus',
                'check', 'times', 'exclamation', 'question', 'info'
            ];
            
            commonIcons.forEach(icon => loadSVGIcon(icon));
        }
            
            function drawFallbackIcon(ctx, x, y) {
                // Simple pin icon as fallback
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(x, y - 3, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(x, y + 1);
                ctx.lineTo(x - 3, y + 6);
                ctx.lineTo(x + 3, y + 6);
                ctx.closePath();
                ctx.fill();
            }
                        
            function getFontAwesomeUnicode(iconClass) {
                // Map of common Font Awesome icon names to their Unicode values
                const iconMap = {
                    'fa-tree': '\uf1bb',
                    'fa-mountain': '\uf6fc',
                    'fa-hospital': '\uf0f8',
                    'fa-school': '\uf549',
                    'fa-church': '\uf51d',
                    'fa-mosque': '\uf678',
                    'fa-synagogue': '\uf69b',
                    'fa-landmark': '\uf66f',
                    'fa-monument': '\uf5a6',
                    'fa-flag': '\uf024',
                    'fa-star': '\uf005',
                    'fa-circle': '\uf111',
                    'fa-square': '\uf0c8',
                    'fa-heart': '\uf004',
                    'fa-home': '\uf015',
                    'fa-building': '\uf1ad',
                    'fa-industry': '\uf275',
                    'fa-bridge': '\ue4c8',
                    'fa-train': '\uf238',
                    'fa-plane': '\uf072',
                    'fa-ship': '\uf21a',
                    'fa-anchor': '\uf13d',
                    'fa-campground': '\uf6bb',
                    'fa-fire': '\uf06d',
                    'fa-gas-pump': '\uf52f',
                    'fa-hotel': '\uf594',
                    'fa-utensils': '\uf2e7',
                    'fa-coffee': '\uf0f4',
                    'fa-shopping-cart': '\uf07a',
                    'fa-hospital-alt': '\uf47d',
                    'fa-plus': '\u002b',
                    'fa-minus': '\uf068',
                    'fa-times': '\uf00d',
                    'fa-check': '\uf00c',
                    'fa-exclamation': '\uf12a',
                    'fa-question': '\uf128',
                    'fa-info': '\uf129',
                    'fa-warning': '\uf071',
                    'fa-skull': '\uf54c',
                    'fa-bomb': '\uf1e2',
                    'fa-radiation': '\uf7b9',
                    'fa-biohazard': '\uf780'
                };
            
                // Extract the icon name from the class (e.g., "fa-solid fa-tree" -> "fa-tree")
                const parts = iconClass.split(' ');
                for (const part of parts) {
                    if (part.startsWith('fa-') && !part.startsWith('fa-solid') && 
                        !part.startsWith('fa-regular') && !part.startsWith('fa-light') && 
                        !part.startsWith('fa-brands')) {
                        return iconMap[part] || null;
                    }
                }
                
                return null;
            }
    
            function exportSVG() {
                const bounds = calculateMapBounds();
                const width = (bounds.maxX - bounds.minX) * baseScale + 100;
                const height = (bounds.maxY - bounds.minY) * baseScale + 100;
                const offsetX = -bounds.minX * baseScale + 50;
                const offsetY = -bounds.minY * baseScale + 50;
    
                let svg = `<?xml version="1.0" encoding="UTF-8"?>
    <svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">
        <desc>Vector map created with Vector Map Designer. Scale: ${baseScale} pixels/km</desc>
        <rect width="100%" height="100%" fill="#f8f9fa"/>
        
    `;
    
                if (mapData.waterBodies.length > 0) {
                    svg += '    <!-- Water Bodies -->\n    <g id="waterBodies">';
                    mapData.waterBodies.forEach((polygon, index) => {
                        const pathD = polygon.points.map((p, i) => 
                            `${i === 0 ? 'M' : 'L'} ${(p.x * baseScale + offsetX).toFixed(2)} ${(p.y * baseScale + offsetY).toFixed(2)}`
                        ).join(' ') + ' Z';
                        const area = calculatePolygonArea(polygon.points);
                        
                        svg += `\n        <path d="${pathD}" fill="rgba(52, 152, 219, 0.4)" stroke="#3498db" stroke-width="2">
                <title>Water Body #${index + 1} - Area: ${area.toFixed(2)} km¬≤</title>
            </path>`;
                    });
                    svg += '\n    </g>\n';
                }
    
                svg += addPathGroup(mapData.rivers, 'rivers', '#3498db', 6, offsetX, offsetY);
                svg += addPathGroup(mapData.roads, 'roads', '#95a5a6', 4, offsetX, offsetY);
                svg += addPathGroup(mapData.highways, 'highways', '#e74c3c', 8, offsetX, offsetY);
                
                // Add custom paths
                if (mapData.customPaths && mapData.customPaths.length > 0) {
                    // Group by tool type
                    const pathsByTool = {};
                    mapData.customPaths.forEach(path => {
                        if (!pathsByTool[path.type]) {
                            pathsByTool[path.type] = [];
                        }
                        pathsByTool[path.type].push(path);
                    });
                    
                    // Export each group
                    Object.keys(pathsByTool).forEach(toolType => {
                        const customTool = getCustomPathToolById(toolType);
                        if (customTool) {
                            const dashArray = customTool.style === 'dashed' ? '10 5' : 
                                            customTool.style === 'dotted' ? '2 3' : '';
                            svg += addPathGroup(pathsByTool[toolType], customTool.name, 
                                              customTool.color, customTool.thickness, 
                                              offsetX, offsetY, dashArray);
                        }
                    });
                }
                
                if (mapData.borders.length > 0) {
                    svg += '    <!-- Borders -->\n    <g id="borders">';
                    mapData.borders.forEach((polygon, index) => {
                        const pathD = polygon.points.map((p, i) => 
                            `${i === 0 ? 'M' : 'L'} ${(p.x * baseScale + offsetX).toFixed(2)} ${(p.y * baseScale + offsetY).toFixed(2)}`
                        ).join(' ') + ' Z';
                        const area = calculatePolygonArea(polygon.points);
                        
                        svg += `\n        <path d="${pathD}" fill="none" stroke="#34495e" stroke-width="3" stroke-dasharray="10 5">
                <title>Border #${index + 1} - Area: ${area.toFixed(2)} km¬≤</title>
            </path>`;
                    });
                    svg += '\n    </g>\n';
                }
    
                if (mapData.cities.length > 0) {
                    svg += '\n    <!-- Cities -->\n    <g id="cities">';
                    mapData.cities.forEach(city => {
                        svg += `\n        <circle cx="${(city.x * baseScale + offsetX).toFixed(2)}" cy="${(city.y * baseScale + offsetY).toFixed(2)}" r="8" fill="#f39c12" stroke="#e67e22" stroke-width="2">
                <title>${city.name} (${city.x.toFixed(2)}, ${city.y.toFixed(2)} km)</title>
            </circle>
            <text x="${(city.x * baseScale + offsetX).toFixed(2)}" y="${(city.y * baseScale + offsetY - 12).toFixed(2)}" text-anchor="middle" font-family="Arial" font-size="14" font-weight="bold" fill="#2c3e50">${city.name}</text>`;
                    });
                    svg += '\n    </g>';
                }

            if (mapData.customPoints.length > 0) {
                        svg += '\n    <!-- Custom Points -->\n    <g id="customPoints">';
                        mapData.customPoints.forEach(point => {
                            const iconUnicode = getFontAwesomeUnicode(point.icon);
                            const iconDisplay = iconUnicode || 'üìç';
                            
                            svg += `\n        <circle cx="${(point.x * baseScale + offsetX).toFixed(2)}" cy="${(point.y * baseScale + offsetY).toFixed(2)}" r="12" fill="#9b59b6" stroke="#8e44ad" stroke-width="2">
                    <title>${point.label || 'Custom Point'} (${point.x.toFixed(2)}, ${point.y.toFixed(2)} km)</title>
                </circle>`;
                            
                            if (point.label) {
                                svg += `\n        <text x="${(point.x * baseScale + offsetX).toFixed(2)}" y="${(point.y * baseScale + offsetY + 16).toFixed(2)}" text-anchor="middle" font-family="Arial" font-size="12" font-weight="bold" fill="#2c3e50">${point.label}</text>`;
                            }
                        });
                        svg += '\n    </g>';
                    }
    
                svg += '\n</svg>';
    
                const blob = new Blob([svg], { type: 'image/svg+xml' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.download = 'map-design.svg';
                link.href = url;
                link.click();
                URL.revokeObjectURL(url);
            }
    
            function addPathGroup(paths, type, color, width, offsetX, offsetY, dashArray = '') {
                if (paths.length === 0) return '';
                
                let group = `\n    <!-- ${type} -->\n    <g id="${type}">`;
                paths.forEach((path, index) => {
                    const length = calculatePathLength(path.points);
                    const pathD = path.points.map((p, i) => 
                        `${i === 0 ? 'M' : 'L'} ${(p.x * baseScale + offsetX).toFixed(2)} ${(p.y * baseScale + offsetY).toFixed(2)}`
                    ).join(' ');
                    
                    const dashAttr = dashArray ? ` stroke-dasharray="${dashArray}"` : '';
                    group += `\n        <path d="${pathD}" stroke="${color}" stroke-width="${width}" fill="none" stroke-linecap="round" stroke-linejoin="round"${dashAttr}>
                <title>${type} #${index + 1} - ${length.toFixed(2)} km</title>
            </path>`;
                });
                group += '\n    </g>';
                return group;
            }
    
            function calculateMapBounds() {
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    
                const allPathCollections = [
                    ...mapData.highways, 
                    ...mapData.roads, 
                    ...mapData.rivers, 
                    ...mapData.waterBodies, 
                    ...mapData.borders
                ];
                
                // Include custom paths
                if (mapData.customPaths && mapData.customPaths.length > 0) {
                    allPathCollections.push(...mapData.customPaths);
                }
                
                allPathCollections.forEach(item => {
                    item.points.forEach(p => {
                        minX = Math.min(minX, p.x);
                        minY = Math.min(minY, p.y);
                        maxX = Math.max(maxX, p.x);
                        maxY = Math.max(maxY, p.y);
                    });
                });
    
                mapData.cities.forEach(city => {
                    minX = Math.min(minX, city.x);
                    minY = Math.min(minY, city.y);
                    maxX = Math.max(maxX, city.x);
                    maxY = Math.max(maxY, city.y);
                });
    
                return minX === Infinity ? { minX: 0, minY: 0, maxX: 100, maxY: 100 } : { minX, minY, maxX, maxY };
            }
    
            function updateBaseScale() {
                const newScale = parseFloat(document.getElementById('baseScale').value);
                if (newScale > 0 && newScale <= 100) {
                    baseScale = newScale;
                    updateZoomDisplay();
                    redrawCanvas();
                } else {
                    alert('Please enter a valid scale between 1 and 100');
                    document.getElementById('baseScale').value = baseScale;
                }
            }
        </script>
        
        <div id="editPointModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; justify-content: center; align-items: center;">
            <div style="background: white; padding: 30px; border-radius: 8px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); max-width: 400px; width: 90%;">
                <h3 style="margin-top: 0; color: #2c3e50;">Edit Custom Point</h3>
                <label style="display: block; margin-bottom: 15px;">
                    Icon:
                    <input type="text" id="editIcon" style="width: 100%; padding: 8px; margin-top: 5px; border: 1px solid #bdc3c7; border-radius: 4px;">
                </label>
                <label style="display: block; margin-bottom: 15px;">
                    Label:
                    <input type="text" id="editLabel" style="width: 100%; padding: 8px; margin-top: 5px; border: 1px solid #bdc3c7; border-radius: 4px;">
                </label>
                <label style="display: block; margin-bottom: 20px;">
                    URL:
                    <input type="text" id="editURL" style="width: 100%; padding: 8px; margin-top: 5px; border: 1px solid #bdc3c7; border-radius: 4px;">
                </label>
                <div style="display: flex; gap: 10px;">
                    <button onclick="savePointEdit()" style="flex: 1; padding: 10px; background: #27ae60; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">Save</button>
                    <button onclick="deletePointFromModal()" style="flex: 1; padding: 10px; background: #e74c3c; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">Delete</button>
                    <button onclick="closeEditModal()" style="flex: 1; padding: 10px; background: #95a5a6; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">Cancel</button>
                </div>
            </div>
        </div>

    <input type="file" id="jsonFileInput" accept="application/json,.json" style="display: none;" onchange="handleFileImport(event)">
        </body>
        </html>